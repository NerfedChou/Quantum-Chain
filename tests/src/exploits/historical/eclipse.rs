//! # Eclipse Attack (Ethereum 2016)
//!
//! ## Attack Vector
//! Attacker controls all of a node's peer connections, isolating it from
//! the honest network.

use crate::exploits::helpers::keccak256;
use qc_01_peer_discovery::{
    IpAddr, KademliaConfig, NodeId, PeerInfo, RoutingTable, SocketAddr, Timestamp,
};
use std::sync::Arc;
use tokio::sync::Mutex;

fn create_targeted_peer(target: &NodeId, bucket_idx: usize, variant: u8) -> PeerInfo {
    let mut id_bytes = *target.as_bytes();

    let byte_idx = bucket_idx / 8;
    let bit_idx = bucket_idx % 8;
    if byte_idx < 32 {
        id_bytes[byte_idx] ^= 1 << (7 - bit_idx);
    }
    id_bytes[31] = variant;

    PeerInfo::new(
        NodeId::new(id_bytes),
        SocketAddr::new(
            IpAddr::v4(192, 168, (bucket_idx % 256) as u8, variant),
            30303,
        ),
        Timestamp::new(1000),
    )
}

/// Test: Sybil attack - concurrent flooding with fake nodes
#[tokio::test(flavor = "multi_thread", worker_threads = 10)]
async fn test_sybil_eclipse_attack() {
    let victim_id = NodeId::new([0x42; 32]);
    let config = KademliaConfig::default();
    let routing_table = Arc::new(Mutex::new(RoutingTable::new(victim_id.clone(), config)));

    let mut handles = vec![];

    for attacker_id in 0..100u8 {
        let rt = routing_table.clone();
        let target = victim_id.clone();

        handles.push(tokio::spawn(async move {
            let mut added = 0;
            for variant in 0..10u8 {
                let bucket = ((attacker_id as usize * 10) + variant as usize) % 256;
                let fake_peer = create_targeted_peer(&target, bucket, variant + attacker_id);

                let mut guard = rt.lock().await;
                if guard.stage_peer(fake_peer, Timestamp::new(1000)).is_ok() {
                    added += 1;
                }
                drop(guard);
                tokio::task::yield_now().await;
            }
            added
        }));
    }

    let mut total_added = 0;
    for handle in handles {
        total_added += handle.await.unwrap();
    }

    let guard = routing_table.lock().await;
    let stats = guard.stats(Timestamp::new(2000));

    println!(
        "Sybil attack: {} add attempts, {} pending verification",
        total_added, stats.pending_verification_count
    );
}

/// Test: Defense - proof of work simulation
#[test]
fn test_defense_proof_of_work_simulation() {
    let difficulty = 16;
    let mut valid_proofs = 0;
    let mut attempts = 0;

    for seed in 0..1000u32 {
        attempts += 1;
        let proof = keccak256(&seed.to_le_bytes());

        let leading_zeros = proof.iter().take(difficulty / 8 + 1).fold(0, |acc, &byte| {
            if acc < difficulty {
                acc + byte.leading_zeros() as usize
            } else {
                acc
            }
        });

        if leading_zeros >= difficulty {
            valid_proofs += 1;
        }
    }

    println!(
        "PoW defense: {} attempts, {} valid proofs (difficulty {})",
        attempts, valid_proofs, difficulty
    );

    assert!(
        valid_proofs < 10,
        "Too many proofs passed - difficulty too low"
    );

    println!("âœ… PoW makes Sybil attack expensive");
}
