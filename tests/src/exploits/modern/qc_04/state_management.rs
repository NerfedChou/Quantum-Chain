//! # State Management (qc-04) Brutal Exploit Tests
//!
//! UNFORGIVING attacks against the State Management subsystem.
//! These tests attempt to break INVARIANT-1 through INVARIANT-8 from SPEC-04.
//!
//! ## Attack Vectors:
//! 1. **Trie Corruption** - Attempt to bypass Merkle Patricia Trie integrity
//! 2. **State Root Forgery** - Forge or manipulate state roots
//! 3. **Concurrent State Attacks** - Race conditions in state transitions
//! 4. **Proof Verification Bypass** - Invalid proofs that appear valid
//! 5. **Snapshot Exploitation** - Corrupt or forge historical snapshots
//! 6. **IPC Authorization Bypass** - Unauthorized state mutations
//! 7. **Memory Exhaustion** - State bloat attacks
//! 8. **Replay State Transitions** - Re-apply old state changes

use qc_04_state_management::domain::{
    entities::{AccountState, StateConfig, EMPTY_TRIE_ROOT},
    proofs::StateProof,
    trie::{verify_proof, PatriciaMerkleTrie},
};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use tokio::sync::Mutex;

type Address = [u8; 20];
type StorageKey = [u8; 32];
type StorageValue = [u8; 32];

// ============================================================================
// TRIE CORRUPTION ATTACKS
// ============================================================================

/// BRUTAL TEST: Attempt to corrupt trie by inserting invalid nodes
#[test]
fn brutal_trie_corruption_invalid_nodes() {
    let mut trie = PatriciaMerkleTrie::new();

    // Insert valid state
    let addr1: Address = [0x11; 20];
    let state1 = AccountState {
        nonce: 1,
        balance: 1000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };

    trie.insert_account(addr1, &state1).unwrap();
    let _root_before = trie.root_hash();

    // ATTACK: Try to insert account with invalid/malformed data
    let malicious_addr: Address = [0xFF; 20];
    let malicious_state = AccountState {
        nonce: u64::MAX,          // Edge case
        balance: u128::MAX,       // Maximum possible
        storage_root: [0xFF; 32], // Invalid root
        code_hash: [0xFF; 32],
    };

    // This should either reject or handle gracefully
    let _result = trie.insert_account(malicious_addr, &malicious_state);

    // Original state must be intact
    let retrieved = trie.get_account(addr1).unwrap().unwrap();
    assert_eq!(
        retrieved.nonce, 1,
        "VULNERABILITY: Original state corrupted!"
    );
    assert_eq!(retrieved.balance, 1000, "VULNERABILITY: Balance corrupted!");

    println!("✅ Trie resisted corruption attack - original state intact");
}

/// BRUTAL TEST: Path collision attack on trie
#[test]
fn brutal_trie_path_collision_attack() {
    let mut trie = PatriciaMerkleTrie::new();

    // Insert legitimate account
    let victim_addr: Address = [0x12; 20];
    let victim_state = AccountState {
        nonce: 100,
        balance: 1_000_000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(victim_addr, &victim_state).unwrap();

    // ATTACK: Create addresses that might collide in trie path
    // Try addresses with similar prefixes
    for i in 0..255u8 {
        let mut attacker_addr_bytes: Address = [0x12; 20];
        attacker_addr_bytes[19] = i;

        if attacker_addr_bytes == victim_addr {
            continue;
        }

        let attacker_state = AccountState {
            nonce: 999,
            balance: 0,
            storage_root: EMPTY_TRIE_ROOT,
            code_hash: [0u8; 32],
        };

        trie.insert_account(attacker_addr_bytes, &attacker_state)
            .unwrap();
    }

    // Victim account must be unchanged
    let victim_retrieved = trie.get_account(victim_addr).unwrap().unwrap();
    assert_eq!(
        victim_retrieved.balance, 1_000_000,
        "VULNERABILITY: Victim balance changed by collision attack!"
    );
    assert_eq!(
        victim_retrieved.nonce, 100,
        "VULNERABILITY: Victim nonce changed by collision attack!"
    );

    println!("✅ Trie resisted path collision attack");
}

// ============================================================================
// STATE ROOT FORGERY ATTACKS
// ============================================================================

/// BRUTAL TEST: Attempt to forge a state root
#[test]
fn brutal_state_root_forgery() {
    let mut trie = PatriciaMerkleTrie::new();

    // Create legitimate state
    let addr: Address = [0xAA; 20];
    let state = AccountState {
        nonce: 1,
        balance: 1000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr, &state).unwrap();

    let legitimate_root = trie.root_hash();

    // ATTACK: Create forged root by modifying bytes
    let mut forged_root = legitimate_root;
    forged_root[0] ^= 0xFF; // Flip bits

    // Generate proof against legitimate trie
    let proof = trie.generate_proof(addr).unwrap();

    // Proof should NOT verify against forged root
    let verify_result = verify_proof(&proof, &addr, &forged_root);
    assert!(
        !verify_result,
        "VULNERABILITY: Proof verified against forged root!"
    );

    // But should verify against legitimate root
    assert!(
        verify_proof(&proof, &addr, &legitimate_root),
        "Proof should verify against legitimate root"
    );

    println!("✅ State root forgery correctly rejected");
}

/// BRUTAL TEST: Second preimage attack on state root
#[test]
fn brutal_second_preimage_attack() {
    let mut trie1 = PatriciaMerkleTrie::new();
    let mut trie2 = PatriciaMerkleTrie::new();

    // Trie 1: Victim with high balance
    let addr: Address = [0xBB; 20];
    let rich_state = AccountState {
        nonce: 1,
        balance: 1_000_000_000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie1.insert_account(addr, &rich_state).unwrap();
    let root1 = trie1.root_hash();

    // Trie 2: Attacker tries to create same root with different balance
    let poor_state = AccountState {
        nonce: 1,
        balance: 0, // Different balance!
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie2.insert_account(addr, &poor_state).unwrap();
    let root2 = trie2.root_hash();

    // Roots MUST be different (cryptographic hash property)
    assert_ne!(
        root1, root2,
        "VULNERABILITY: Different states produced same root - hash collision!"
    );

    println!("✅ Second preimage attack failed - different states have different roots");
}

// ============================================================================
// CONCURRENT STATE ATTACKS
// ============================================================================

/// BRUTAL TEST: Race condition in state updates
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn brutal_concurrent_state_race_condition() {
    let trie = Arc::new(Mutex::new(PatriciaMerkleTrie::new()));
    let addr: Address = [0xCC; 20];

    // Initialize account
    {
        let mut guard = trie.lock().await;
        let initial = AccountState {
            nonce: 0,
            balance: 10_000,
            storage_root: EMPTY_TRIE_ROOT,
            code_hash: [0u8; 32],
        };
        guard.insert_account(addr, &initial).unwrap();
    }

    let successful_updates = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    // 50 threads trying to increment nonce concurrently
    for _ in 0..50 {
        let t = trie.clone();
        let counter = successful_updates.clone();

        handles.push(tokio::spawn(async move {
            let mut guard = t.lock().await;

            // Read current state
            let current = guard.get_account(addr).unwrap().unwrap();

            // Increment nonce
            let updated = AccountState {
                nonce: current.nonce + 1,
                balance: current.balance,
                storage_root: current.storage_root,
                code_hash: current.code_hash,
            };

            guard.insert_account(addr, &updated).unwrap();
            counter.fetch_add(1, Ordering::SeqCst);
        }));
    }

    for handle in handles {
        handle.await.unwrap();
    }

    // Final nonce should be exactly 50 (all updates applied)
    let final_state = {
        let guard = trie.lock().await;
        guard.get_account(addr).unwrap().unwrap()
    };

    assert_eq!(
        final_state.nonce,
        50,
        "VULNERABILITY: Race condition lost {} updates!",
        50 - final_state.nonce
    );

    println!("✅ All 50 concurrent updates applied correctly - no race condition");
}

/// BRUTAL TEST: Double-spend via concurrent balance updates
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn brutal_double_spend_attack() {
    let trie = Arc::new(Mutex::new(PatriciaMerkleTrie::new()));
    let addr: Address = [0xDD; 20];

    // Initialize with balance of 1000
    {
        let mut guard = trie.lock().await;
        let initial = AccountState {
            nonce: 0,
            balance: 1000,
            storage_root: EMPTY_TRIE_ROOT,
            code_hash: [0u8; 32],
        };
        guard.insert_account(addr, &initial).unwrap();
    }

    let overdraft_attempts = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    // 20 threads each trying to spend 100 (total 2000, but only 1000 available)
    for _ in 0..20 {
        let t = trie.clone();
        let overdraft = overdraft_attempts.clone();

        handles.push(tokio::spawn(async move {
            let mut guard = t.lock().await;

            let current = guard.get_account(addr).unwrap().unwrap();

            // Check if we have enough balance
            if current.balance >= 100 {
                let updated = AccountState {
                    nonce: current.nonce + 1,
                    balance: current.balance - 100,
                    storage_root: current.storage_root,
                    code_hash: current.code_hash,
                };
                guard.insert_account(addr, &updated).unwrap();
            } else {
                overdraft.fetch_add(1, Ordering::SeqCst);
            }
        }));
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let final_state = {
        let guard = trie.lock().await;
        guard.get_account(addr).unwrap().unwrap()
    };

    // Balance should be >= 0 (never negative)
    assert!(
        final_state.balance <= 1000,
        "VULNERABILITY: Balance went over initial - double spend!"
    );

    // Should have rejected some transactions
    let rejected = overdraft_attempts.load(Ordering::SeqCst);
    assert!(
        rejected >= 10,
        "Should have rejected at least 10 overdraft attempts, rejected: {}",
        rejected
    );

    println!(
        "✅ Double-spend attack prevented - {} overdraft attempts rejected",
        rejected
    );
}

// ============================================================================
// PROOF VERIFICATION BYPASS ATTACKS
// ============================================================================

/// BRUTAL TEST: Tampered proof bytes
#[test]
fn brutal_tampered_proof_rejection() {
    let mut trie = PatriciaMerkleTrie::new();

    let addr: Address = [0xEE; 20];
    let state = AccountState {
        nonce: 42,
        balance: 999_999,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr, &state).unwrap();
    let root = trie.root_hash();

    // Generate valid proof
    let valid_proof = trie.generate_proof(addr).unwrap();

    // ATTACK: Create tampered proof with modified state root
    let mut tampered_root = root;
    tampered_root[0] ^= 0xFF;

    let tampered_proof = StateProof::new(addr, Some(state.clone()), tampered_root);

    // Tampered proof must be rejected
    let result = verify_proof(&tampered_proof, &addr, &root);
    assert!(!result, "VULNERABILITY: Tampered proof was accepted!");

    // Original proof should still work
    assert!(
        verify_proof(&valid_proof, &addr, &root),
        "Valid proof should still verify"
    );

    println!("✅ Tampered proof correctly rejected");
}

/// BRUTAL TEST: Proof for wrong address
#[test]
fn brutal_wrong_address_proof() {
    let mut trie = PatriciaMerkleTrie::new();

    // Two different accounts
    let rich_addr: Address = [0x11; 20];
    let poor_addr: Address = [0x22; 20];

    let rich_state = AccountState {
        nonce: 1,
        balance: 1_000_000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    let poor_state = AccountState {
        nonce: 1,
        balance: 100,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };

    trie.insert_account(rich_addr, &rich_state).unwrap();
    trie.insert_account(poor_addr, &poor_state).unwrap();
    let root = trie.root_hash();

    // ATTACK: Get proof for rich account, try to use for poor account
    let rich_proof = trie.generate_proof(rich_addr).unwrap();

    // Must fail when verified against wrong address
    let cross_verify = verify_proof(&rich_proof, &poor_addr, &root);
    assert!(
        !cross_verify,
        "VULNERABILITY: Proof for wrong address accepted!"
    );

    println!("✅ Wrong-address proof correctly rejected");
}

/// BRUTAL TEST: Empty/null proof attack
#[test]
fn brutal_empty_proof_attack() {
    let mut trie = PatriciaMerkleTrie::new();

    let addr: Address = [0xFF; 20];
    let state = AccountState {
        nonce: 1,
        balance: 1000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr, &state).unwrap();
    let root = trie.root_hash();

    // ATTACK: Create empty proof
    let empty_proof = StateProof::new(addr, None, [0u8; 32]);

    let result = verify_proof(&empty_proof, &addr, &root);
    assert!(!result, "VULNERABILITY: Empty proof was accepted!");

    println!("✅ Empty proof correctly rejected");
}

// ============================================================================
// IPC AUTHORIZATION ATTACKS
// ============================================================================

/// BRUTAL TEST: Unauthorized state mutation via IPC
#[test]
fn brutal_unauthorized_state_mutation() {
    use shared_types::security::AuthorizationMatrix;

    let matrix = AuthorizationMatrix::new();

    // ATTACK: Consensus (8) trying to call ExecuteBlock (should be from Block Executor 5)
    // Per IPC-MATRIX.md, only specific senders can send to State Management (4)
    let unauthorized_sender = 8u8; // Consensus
    let recipient = 4u8; // State Management

    // Check that random message type is rejected
    let is_authorized = matrix.is_authorized(unauthorized_sender, recipient, "ExecuteBlock");

    assert!(
        !is_authorized,
        "VULNERABILITY: Unauthorized sender was allowed!"
    );

    // But BlockValidated from Consensus to State Mgmt IS authorized
    let valid_auth = matrix.is_authorized(8, 4, "BlockValidated");
    assert!(valid_auth, "Valid authorization should pass");

    println!("✅ Unauthorized state mutation blocked by AuthorizationMatrix");
}

/// BRUTAL TEST: Replay attack on state transition
#[test]
fn brutal_state_transition_replay() {
    use shared_types::security::NonceCache;
    use uuid::Uuid;

    let cache = NonceCache::new();

    // First message with nonce
    let nonce = Uuid::new_v4();

    // First check - should succeed
    assert!(
        cache.check_and_insert(nonce),
        "First message should be accepted"
    );

    // ATTACK: Replay exact same nonce
    let replay_result = cache.check_and_insert(nonce);

    // Should fail - nonce already used
    assert!(!replay_result, "VULNERABILITY: Replay attack succeeded!");

    println!("✅ State transition replay correctly blocked by NonceCache");
}

/// BRUTAL TEST: HMAC signature forgery
#[test]
fn brutal_hmac_signature_forgery() {
    use shared_types::security::{sign_message, validate_hmac_signature};

    let legitimate_secret = b"state-management-secret-key-1234";
    let attacker_secret = b"attacker-guessed-wrong-key-1234";

    let payload = b"execute_block_payload";

    // Legitimate signature
    let legit_sig = sign_message(payload, legitimate_secret);

    // ATTACK: Attacker tries to forge with wrong key
    let forged_sig = sign_message(payload, attacker_secret);

    // Legitimate signature should verify
    assert!(
        validate_hmac_signature(payload, &legit_sig, legitimate_secret),
        "Legitimate signature should verify"
    );

    // Forged signature must be rejected
    assert!(
        !validate_hmac_signature(payload, &forged_sig, legitimate_secret),
        "VULNERABILITY: Forged signature was accepted!"
    );

    println!("✅ HMAC signature forgery correctly rejected");
}

/// BRUTAL TEST: Timestamp manipulation attack
#[test]
fn brutal_timestamp_manipulation() {
    use shared_types::security::{current_timestamp, validate_timestamp, MAX_AGE, MAX_FUTURE_SKEW};

    let now = current_timestamp();

    // Valid timestamp should pass
    assert!(
        validate_timestamp(now).is_ok(),
        "Current timestamp should be valid"
    );

    // ATTACK: Expired timestamp
    let old_timestamp = now - MAX_AGE - 100;
    let expired_result = validate_timestamp(old_timestamp);
    assert!(
        expired_result.is_err(),
        "VULNERABILITY: Expired timestamp accepted!"
    );

    // ATTACK: Future timestamp (clock skew attack)
    let future_timestamp = now + MAX_FUTURE_SKEW + 100;
    let future_result = validate_timestamp(future_timestamp);
    assert!(
        future_result.is_err(),
        "VULNERABILITY: Future timestamp accepted!"
    );

    println!("✅ Timestamp manipulation attacks correctly blocked");
}

// ============================================================================
// MEMORY EXHAUSTION ATTACKS
// ============================================================================

/// BRUTAL TEST: State bloat attack (many accounts)
#[test]
fn brutal_state_bloat_attack() {
    let mut trie = PatriciaMerkleTrie::new();

    // ATTACK: Create 500 accounts to bloat state (reduced for test speed)
    let attack_count = 500;
    let start = std::time::Instant::now();

    for i in 0..attack_count {
        let mut addr_bytes: Address = [0u8; 20];
        addr_bytes[0..4].copy_from_slice(&(i as u32).to_be_bytes());

        let state = AccountState {
            nonce: i as u64,
            balance: i as u128,
            storage_root: EMPTY_TRIE_ROOT,
            code_hash: [0u8; 32],
        };

        trie.insert_account(addr_bytes, &state).unwrap();
    }

    let elapsed = start.elapsed();

    // Should complete in reasonable time (< 30 seconds - allowing for slow CI)
    assert!(
        elapsed.as_secs() < 30,
        "VULNERABILITY: State bloat attack caused performance degradation - took {:?}",
        elapsed
    );

    // Trie should still function
    let first_addr: Address = [0u8; 20];
    let result = trie.get_account(first_addr).unwrap();
    assert!(
        result.is_some(),
        "Trie should still be queryable after bloat"
    );

    println!(
        "✅ State bloat attack handled - {} accounts in {:?}",
        attack_count, elapsed
    );
}

/// BRUTAL TEST: Storage slot exhaustion per account
#[test]
fn brutal_storage_slot_exhaustion() {
    let config = StateConfig {
        max_storage_slots_per_contract: 500,
        ..Default::default()
    };
    let mut trie = PatriciaMerkleTrie::with_config(config);

    let addr: Address = [0xAB; 20];
    let initial = AccountState {
        nonce: 0,
        balance: 1000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr, &initial).unwrap();

    // ATTACK: Create 500 storage slots for one account
    let slot_count = 500;
    let start = std::time::Instant::now();

    for i in 0..slot_count {
        let mut key_bytes: StorageKey = [0u8; 32];
        key_bytes[0..4].copy_from_slice(&(i as u32).to_be_bytes());

        let mut value_bytes: StorageValue = [0u8; 32];
        value_bytes[28..32].copy_from_slice(&(i as u32).to_be_bytes());

        trie.set_storage(addr, key_bytes, value_bytes).unwrap();
    }

    let elapsed = start.elapsed();

    // Should complete in reasonable time
    assert!(
        elapsed.as_secs() < 5,
        "VULNERABILITY: Storage exhaustion caused degradation - took {:?}",
        elapsed
    );

    // Verify random slot
    let mut test_key: StorageKey = [0u8; 32];
    test_key[0..4].copy_from_slice(&100u32.to_be_bytes());
    let retrieved = trie.get_storage(addr, test_key).unwrap();
    assert!(retrieved.is_some(), "Storage slot should be retrievable");

    println!(
        "✅ Storage exhaustion handled - {} slots in {:?}",
        slot_count, elapsed
    );
}

// ============================================================================
// SNAPSHOT EXPLOITATION ATTACKS
// ============================================================================

/// BRUTAL TEST: Attempt to use stale snapshot
#[test]
fn brutal_stale_snapshot_attack() {
    let mut trie = PatriciaMerkleTrie::new();

    let addr: Address = [0x99; 20];

    // State at block 100
    let state_v1 = AccountState {
        nonce: 1,
        balance: 1000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr, &state_v1).unwrap();
    let root_v1 = trie.root_hash();
    let proof_v1 = trie.generate_proof(addr).unwrap();

    // State updated at block 200 (balance changed)
    let state_v2 = AccountState {
        nonce: 2,
        balance: 500, // Spent some
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr, &state_v2).unwrap();
    let root_v2 = trie.root_hash();

    // ATTACK: Try to use old proof with new root
    let stale_attack = verify_proof(&proof_v1, &addr, &root_v2);
    assert!(
        !stale_attack,
        "VULNERABILITY: Stale proof accepted against new root!"
    );

    // Old proof should still work with old root (for historical queries)
    assert!(
        verify_proof(&proof_v1, &addr, &root_v1),
        "Historical proof should verify against historical root"
    );

    println!("✅ Stale snapshot attack correctly blocked");
}

// ============================================================================
// GENESIS PROTECTION TESTS
// ============================================================================

/// BRUTAL TEST: Attempt to modify genesis state
#[test]
fn brutal_genesis_modification_attack() {
    let mut trie = PatriciaMerkleTrie::new();

    // Genesis account (e.g., pre-funded account)
    let genesis_addr: Address = [0x00; 20];
    let genesis_state = AccountState {
        nonce: 0,
        balance: 100_000_000, // Large pre-fund
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(genesis_addr, &genesis_state).unwrap();
    let genesis_root = trie.root_hash();

    // Mark genesis as finalized (in real impl, this would lock it)
    // For now, we just ensure subsequent changes update the root

    // ATTACK: Try to change genesis balance
    let modified_genesis = AccountState {
        nonce: 0,
        balance: 999_999_999, // Attacker wants more!
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(genesis_addr, &modified_genesis)
        .unwrap();
    let modified_root = trie.root_hash();

    // Root MUST change (proving the modification is detectable)
    assert_ne!(
        genesis_root, modified_root,
        "VULNERABILITY: Genesis modification not reflected in root!"
    );

    // In a real system, the genesis root would be hardcoded and
    // any deviation would be rejected at the consensus level

    println!("✅ Genesis modification is detectable via root change");
}

// ============================================================================
// INVARIANT VERIFICATION TESTS
// ============================================================================

/// BRUTAL TEST: Verify all SPEC-04 invariants hold under attack
#[test]
fn brutal_spec04_invariant_verification() {
    let mut trie = PatriciaMerkleTrie::new();

    // INVARIANT-1: Merkle Patricia Trie integrity
    let addr1: Address = [0x01; 20];
    let state1 = AccountState {
        nonce: 1,
        balance: 1000,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr1, &state1).unwrap();
    let root1 = trie.root_hash();

    // Same input must produce same root (determinism)
    let mut trie2 = PatriciaMerkleTrie::new();
    trie2.insert_account(addr1, &state1).unwrap();
    let root2 = trie2.root_hash();
    assert_eq!(
        root1, root2,
        "INVARIANT-1 VIOLATED: Non-deterministic root!"
    );

    // INVARIANT-2: Proof verification
    let proof = trie.generate_proof(addr1).unwrap();
    assert!(
        verify_proof(&proof, &addr1, &root1),
        "INVARIANT-2 VIOLATED: Valid proof failed!"
    );

    // INVARIANT-3: State isolation
    let addr2: Address = [0x02; 20];
    let state2 = AccountState {
        nonce: 99,
        balance: 9999,
        storage_root: EMPTY_TRIE_ROOT,
        code_hash: [0u8; 32],
    };
    trie.insert_account(addr2, &state2).unwrap();

    // addr1 must be unchanged
    let retrieved1 = trie.get_account(addr1).unwrap().unwrap();
    assert_eq!(
        retrieved1.nonce, 1,
        "INVARIANT-3 VIOLATED: Cross-account corruption!"
    );

    // INVARIANT-4: Non-existent account returns None
    let non_existent: Address = [0xFF; 20];
    assert!(
        trie.get_account(non_existent).unwrap().is_none(),
        "INVARIANT-4 VIOLATED: Non-existent account returned data!"
    );

    println!("✅ All SPEC-04 invariants verified under attack conditions");
}
