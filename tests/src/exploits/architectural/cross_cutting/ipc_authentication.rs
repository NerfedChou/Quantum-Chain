//! # IPC Authentication Brutal Tests
//!
//! These tests verify that the IPC security layer correctly:
//! 1. Rejects messages with invalid HMAC signatures
//! 2. Rejects replay attacks (duplicate nonces)
//! 3. Rejects messages with expired timestamps
//!
//! ## Architecture Context
//!
//! Per IPC-MATRIX.md, ALL inter-subsystem messages MUST:
//! - Include HMAC-SHA256 signature over the payload
//! - Include monotonic nonce for replay protection
//! - Include timestamp within acceptable window (30 seconds)
//!
//! ## Attack Vectors Tested
//!
//! 1. **Signature Forgery**: Attacker captures message, modifies payload, keeps original HMAC
//! 2. **Replay Attack**: Attacker captures valid message, replays it later
//! 3. **Timestamp Manipulation**: Attacker sends message with future/past timestamp
//! 4. **Nonce Reuse**: Attacker reuses nonce from previous message
//!
//! ## Reference Documents
//! - IPC-MATRIX.md Section "Security Requirements"
//! - Architecture.md Section "Inter-Subsystem Communication"
//! - System.md Section "Security Model"

use std::collections::HashSet;
use std::time::{SystemTime, UNIX_EPOCH};

// =============================================================================
// MOCK IPC ENVELOPE (Simulates what shared-bus provides)
// =============================================================================

/// IPC Message Envelope with security fields
#[derive(Clone, Debug)]
pub struct IpcEnvelope<T> {
    /// The actual message payload
    pub payload: T,
    /// Sender subsystem ID
    pub sender_id: u8,
    /// HMAC-SHA256 signature over payload
    pub signature: [u8; 32],
    /// Monotonic nonce for replay protection
    pub nonce: u64,
    /// Unix timestamp in seconds
    pub timestamp: u64,
}

/// Security validation result
#[derive(Debug, PartialEq)]
pub enum IpcSecurityError {
    InvalidSignature { expected: [u8; 32], got: [u8; 32] },
    ReplayDetected { nonce: u64 },
    TimestampExpired { age_secs: u64 },
    TimestampFuture { ahead_secs: u64 },
    UnauthorizedSender { sender: u8, expected: Vec<u8> },
}

/// IPC Security Validator
///
/// This simulates the security layer that SHOULD exist in each subsystem's
/// IPC handler. It validates HMAC, nonce, and timestamp.
pub struct IpcSecurityValidator {
    /// Shared secret for HMAC (in production, this comes from secure config)
    shared_secret: [u8; 32],
    /// Set of seen nonces for replay detection
    seen_nonces: HashSet<u64>,
    /// Maximum age for timestamps (30 seconds per spec)
    max_timestamp_age_secs: u64,
}

impl IpcSecurityValidator {
    pub fn new(shared_secret: [u8; 32]) -> Self {
        Self {
            shared_secret,
            seen_nonces: HashSet::new(),
            max_timestamp_age_secs: 30,
        }
    }

    /// Compute HMAC-SHA256 over payload bytes
    pub fn compute_hmac(&self, payload_bytes: &[u8]) -> [u8; 32] {
        use k256::sha2::{Digest, Sha256};

        // HMAC = H(secret || payload)
        // Note: In production, use proper HMAC construction
        let mut hasher = Sha256::new();
        hasher.update(&self.shared_secret);
        hasher.update(payload_bytes);
        hasher.finalize().into()
    }

    /// Validate an IPC envelope
    pub fn validate<T: AsRef<[u8]>>(
        &mut self,
        envelope: &IpcEnvelope<T>,
        authorized_senders: &[u8],
    ) -> Result<(), IpcSecurityError> {
        // 1. Check sender authorization
        if !authorized_senders.contains(&envelope.sender_id) {
            return Err(IpcSecurityError::UnauthorizedSender {
                sender: envelope.sender_id,
                expected: authorized_senders.to_vec(),
            });
        }

        // 2. Verify HMAC signature
        let expected_sig = self.compute_hmac(envelope.payload.as_ref());
        if envelope.signature != expected_sig {
            return Err(IpcSecurityError::InvalidSignature {
                expected: expected_sig,
                got: envelope.signature,
            });
        }

        // 3. Check for replay (nonce reuse)
        if self.seen_nonces.contains(&envelope.nonce) {
            return Err(IpcSecurityError::ReplayDetected {
                nonce: envelope.nonce,
            });
        }
        self.seen_nonces.insert(envelope.nonce);

        // 4. Validate timestamp
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        if envelope.timestamp > now {
            let ahead = envelope.timestamp - now;
            if ahead > 5 {
                // Allow 5 seconds of clock skew
                return Err(IpcSecurityError::TimestampFuture { ahead_secs: ahead });
            }
        } else {
            let age = now - envelope.timestamp;
            if age > self.max_timestamp_age_secs {
                return Err(IpcSecurityError::TimestampExpired { age_secs: age });
            }
        }

        Ok(())
    }
}

/// Helper to create a valid signed envelope
fn create_valid_envelope<T: AsRef<[u8]> + Clone>(
    payload: T,
    sender_id: u8,
    nonce: u64,
    validator: &IpcSecurityValidator,
) -> IpcEnvelope<T> {
    let signature = validator.compute_hmac(payload.as_ref());
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    IpcEnvelope {
        payload,
        sender_id,
        signature,
        nonce,
        timestamp,
    }
}

// =============================================================================
// BRUTAL TESTS: SIGNATURE FORGERY
// =============================================================================

/// BRUTAL TEST: Forged HMAC signature rejected
///
/// Attack: Attacker crafts message with random/zero signature
/// Defense: HMAC verification fails
#[test]
fn brutal_forged_signature_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let payload = b"BlockValidated:hash=0xABCD";
    let forged_signatures = vec![
        ([0u8; 32], "all zeros"),
        ([0xFF; 32], "all ones"),
        ([0xDE; 32], "random pattern"),
        (
            {
                let mut sig = validator.compute_hmac(payload);
                sig[0] ^= 0x01; // Flip one bit
                sig
            },
            "one bit flipped",
        ),
    ];

    for (forged_sig, name) in forged_signatures {
        let envelope = IpcEnvelope {
            payload: payload.to_vec(),
            sender_id: 8, // Consensus
            signature: forged_sig,
            nonce: 1,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        let result = validator.validate(&envelope, &[8]);

        assert!(
            matches!(result, Err(IpcSecurityError::InvalidSignature { .. })),
            "Forged signature '{}' should be rejected",
            name
        );
    }

    println!("✅ All forged signatures correctly rejected");
}

/// BRUTAL TEST: Wrong secret produces different HMAC
///
/// Attack: Attacker signs with their own secret
/// Defense: HMAC mismatch detected
#[test]
fn brutal_wrong_secret_rejected() {
    let real_secret = [0xAA; 32];
    let attacker_secret = [0xBB; 32];

    let mut validator = IpcSecurityValidator::new(real_secret);
    let attacker_validator = IpcSecurityValidator::new(attacker_secret);

    let payload = b"MerkleRootComputed:hash=0x1234";

    // Attacker signs with wrong secret
    let attacker_sig = attacker_validator.compute_hmac(payload);

    let envelope = IpcEnvelope {
        payload: payload.to_vec(),
        sender_id: 3, // Transaction Indexing
        signature: attacker_sig,
        nonce: 1,
        timestamp: SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs(),
    };

    let result = validator.validate(&envelope, &[3]);

    assert!(
        matches!(result, Err(IpcSecurityError::InvalidSignature { .. })),
        "Signature from wrong secret should be rejected"
    );

    println!("✅ Wrong secret correctly produces invalid signature");
}

/// BRUTAL TEST: Modified payload with original signature
///
/// Attack: Attacker intercepts message, modifies payload, keeps original HMAC
/// Defense: HMAC over new payload doesn't match
#[test]
fn brutal_modified_payload_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let original_payload = b"Transfer:from=Alice,to=Bob,amount=100";
    let modified_payload = b"Transfer:from=Alice,to=Eve,amount=100"; // Changed recipient!

    // Get valid signature for original
    let original_sig = validator.compute_hmac(original_payload);

    // Attacker uses original signature with modified payload
    let envelope = IpcEnvelope {
        payload: modified_payload.to_vec(),
        sender_id: 6, // Mempool
        signature: original_sig,
        nonce: 1,
        timestamp: SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs(),
    };

    let result = validator.validate(&envelope, &[6]);

    assert!(
        matches!(result, Err(IpcSecurityError::InvalidSignature { .. })),
        "Modified payload with original signature should be rejected"
    );

    println!("✅ Payload modification correctly detected via HMAC mismatch");
}

// =============================================================================
// BRUTAL TESTS: REPLAY ATTACKS
// =============================================================================

/// BRUTAL TEST: Exact message replay rejected
///
/// Attack: Attacker captures valid message and replays it
/// Defense: Nonce tracking detects duplicate
#[test]
fn brutal_exact_replay_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let payload = b"BlockStorageConfirmation:height=1000";
    let envelope = create_valid_envelope(payload.to_vec(), 2, 42, &validator);

    // First submission succeeds
    let first_result = validator.validate(&envelope, &[2]);
    assert!(first_result.is_ok(), "First submission should succeed");

    // Exact replay with same nonce fails
    let replay_result = validator.validate(&envelope, &[2]);
    assert!(
        matches!(
            replay_result,
            Err(IpcSecurityError::ReplayDetected { nonce: 42 })
        ),
        "Replay with same nonce should be rejected"
    );

    println!("✅ Exact message replay correctly rejected");
}

/// BRUTAL TEST: Multiple replays of same message
///
/// Attack: Attacker replays the same message 100 times
/// Defense: All replays rejected after first
#[test]
fn brutal_multiple_replays_all_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let payload = b"PeerListResponse:peers=10";
    let envelope = create_valid_envelope(payload.to_vec(), 1, 999, &validator);

    // First succeeds
    assert!(validator.validate(&envelope, &[1]).is_ok());

    // All 100 replays fail
    let mut replay_failures = 0;
    for _ in 0..100 {
        if validator.validate(&envelope, &[1]).is_err() {
            replay_failures += 1;
        }
    }

    assert_eq!(replay_failures, 100, "All 100 replays should fail");

    println!("✅ All 100 replay attempts correctly rejected");
}

/// BRUTAL TEST: Nonce reuse with different payload
///
/// Attack: Attacker reuses nonce from previous message but with different payload
/// Defense: Nonce tracking still catches it
#[test]
fn brutal_nonce_reuse_different_payload_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    // First message
    let payload1 = b"Message1:data=legitimate";
    let envelope1 = create_valid_envelope(payload1.to_vec(), 8, 777, &validator);
    assert!(validator.validate(&envelope1, &[8]).is_ok());

    // Second message with SAME nonce but different payload
    let payload2 = b"Message2:data=malicious";
    let envelope2 = create_valid_envelope(payload2.to_vec(), 8, 777, &validator); // Same nonce!

    let result = validator.validate(&envelope2, &[8]);
    assert!(
        matches!(result, Err(IpcSecurityError::ReplayDetected { nonce: 777 })),
        "Nonce reuse should be rejected even with different payload"
    );

    println!("✅ Nonce reuse with different payload correctly rejected");
}

/// BRUTAL TEST: Sequential nonces accepted
///
/// Verify: Different nonces for different messages work
#[test]
fn brutal_sequential_nonces_accepted() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    // Send 100 messages with sequential nonces
    for nonce in 0..100u64 {
        let payload = format!("Message:seq={}", nonce);
        let envelope = create_valid_envelope(payload.into_bytes(), 8, nonce, &validator);

        let result = validator.validate(&envelope, &[8]);
        assert!(
            result.is_ok(),
            "Message {} with nonce {} should be accepted",
            nonce,
            nonce
        );
    }

    println!("✅ 100 sequential nonces all accepted");
}

// =============================================================================
// BRUTAL TESTS: TIMESTAMP ATTACKS
// =============================================================================

/// BRUTAL TEST: Expired timestamp rejected
///
/// Attack: Attacker replays old message (captured hours ago)
/// Defense: Timestamp outside 30-second window rejected
#[test]
fn brutal_expired_timestamp_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let payload = b"OldMessage:captured_hours_ago";
    let sig = validator.compute_hmac(payload);

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    let expired_timestamps = vec![
        (now - 31, "31 seconds ago"),
        (now - 60, "1 minute ago"),
        (now - 3600, "1 hour ago"),
        (now - 86400, "1 day ago"),
    ];

    for (timestamp, name) in expired_timestamps {
        let envelope = IpcEnvelope {
            payload: payload.to_vec(),
            sender_id: 8,
            signature: sig,
            nonce: timestamp, // Use timestamp as nonce to avoid collision
            timestamp,
        };

        let result = validator.validate(&envelope, &[8]);
        assert!(
            matches!(result, Err(IpcSecurityError::TimestampExpired { .. })),
            "Timestamp '{}' should be rejected as expired",
            name
        );
    }

    println!("✅ All expired timestamps correctly rejected");
}

/// BRUTAL TEST: Future timestamp rejected
///
/// Attack: Attacker sends message with future timestamp (clock manipulation)
/// Defense: Timestamps more than 5 seconds in future rejected
#[test]
fn brutal_future_timestamp_rejected() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let payload = b"FutureMessage:timestamp_manipulated";
    let sig = validator.compute_hmac(payload);

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    let future_timestamps = vec![
        (now + 10, "10 seconds ahead"),
        (now + 60, "1 minute ahead"),
        (now + 3600, "1 hour ahead"),
    ];

    for (timestamp, name) in future_timestamps {
        let envelope = IpcEnvelope {
            payload: payload.to_vec(),
            sender_id: 8,
            signature: sig,
            nonce: timestamp,
            timestamp,
        };

        let result = validator.validate(&envelope, &[8]);
        assert!(
            matches!(result, Err(IpcSecurityError::TimestampFuture { .. })),
            "Timestamp '{}' should be rejected as future",
            name
        );
    }

    println!("✅ All future timestamps correctly rejected");
}

/// BRUTAL TEST: Timestamp within window accepted
///
/// Verify: Timestamps within 30-second window accepted
#[test]
fn brutal_valid_timestamp_window_accepted() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    let valid_timestamps = vec![
        (now, "exactly now"),
        (now - 1, "1 second ago"),
        (now - 10, "10 seconds ago"),
        (now - 29, "29 seconds ago"),
        (now + 1, "1 second ahead"),
        (now + 4, "4 seconds ahead (within skew)"),
    ];

    for (i, (timestamp, name)) in valid_timestamps.into_iter().enumerate() {
        let payload = format!("ValidMessage:{}", i);
        let sig = validator.compute_hmac(payload.as_bytes());

        let envelope = IpcEnvelope {
            payload: payload.into_bytes(),
            sender_id: 8,
            signature: sig,
            nonce: i as u64,
            timestamp,
        };

        let result = validator.validate(&envelope, &[8]);
        assert!(result.is_ok(), "Timestamp '{}' should be accepted", name);
    }

    println!("✅ All valid timestamps within window accepted");
}

// =============================================================================
// BRUTAL TESTS: COMBINED ATTACKS
// =============================================================================

/// BRUTAL TEST: BlockStorageConfirmation replay attack
///
/// Scenario from Gemini: Replaying BlockStorageConfirmation could cause
/// mempool to delete transactions that weren't actually confirmed.
#[test]
fn brutal_block_storage_confirmation_replay() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    // Simulated BlockStorageConfirmation from Block Storage (2)
    let confirmation_payload = b"BlockStorageConfirmation:block_hash=0xABCD,height=1000";
    let envelope = create_valid_envelope(confirmation_payload.to_vec(), 2, 12345, &validator);

    // First confirmation is legitimate
    assert!(validator.validate(&envelope, &[2]).is_ok());

    // Later, attacker replays this confirmation
    // This would cause mempool to re-delete transactions at height 1000
    let replay_result = validator.validate(&envelope, &[2]);

    assert!(
        matches!(
            replay_result,
            Err(IpcSecurityError::ReplayDetected { nonce: 12345 })
        ),
        "BlockStorageConfirmation replay should be rejected"
    );

    println!("✅ BlockStorageConfirmation replay attack correctly prevented");
}

/// BRUTAL TEST: Full attack chain simulation
///
/// Simulates an attacker who has compromised one subsystem and is
/// trying various attacks on another.
#[test]
fn brutal_compromised_subsystem_attack_chain() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    // Attacker has compromised Subsystem 7 (Bloom Filters)
    // They're trying to send messages pretending to be Consensus (8)

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    // Attack 1: Spoof sender ID
    let payload = b"BlockValidated:fake_block";
    let sig = validator.compute_hmac(payload);
    let spoof_envelope = IpcEnvelope {
        payload: payload.to_vec(),
        sender_id: 7, // Bloom Filters - not authorized for BlockValidated
        signature: sig,
        nonce: 1,
        timestamp: now,
    };

    // Block Storage only accepts BlockValidated from Consensus (8)
    let spoof_result = validator.validate(&spoof_envelope, &[8]);
    assert!(
        matches!(
            spoof_result,
            Err(IpcSecurityError::UnauthorizedSender { sender: 7, .. })
        ),
        "Sender spoofing should be rejected"
    );

    // Attack 2: Try forging signature (attacker doesn't know secret)
    let attacker_secret = [0xEE; 32]; // Wrong secret
    let attacker_validator = IpcSecurityValidator::new(attacker_secret);
    let forged_sig = attacker_validator.compute_hmac(payload);

    let forge_envelope = IpcEnvelope {
        payload: payload.to_vec(),
        sender_id: 8, // Claim to be Consensus
        signature: forged_sig,
        nonce: 2,
        timestamp: now,
    };

    let forge_result = validator.validate(&forge_envelope, &[8]);
    assert!(
        matches!(forge_result, Err(IpcSecurityError::InvalidSignature { .. })),
        "Forged signature should be rejected"
    );

    // Attack 3: Capture and replay a legitimate message
    let legit_envelope = create_valid_envelope(payload.to_vec(), 8, 3, &validator);
    assert!(validator.validate(&legit_envelope, &[8]).is_ok());

    let replay_result = validator.validate(&legit_envelope, &[8]);
    assert!(
        matches!(replay_result, Err(IpcSecurityError::ReplayDetected { .. })),
        "Replay attack should be rejected"
    );

    println!("✅ Full compromised subsystem attack chain correctly defended");
}

// =============================================================================
// BRUTAL TESTS: STRESS AND EDGE CASES
// =============================================================================

/// BRUTAL TEST: High-volume nonce tracking doesn't leak memory
///
/// Verify: Processing 10,000 messages doesn't cause unbounded growth
#[test]
fn brutal_nonce_tracking_memory_bounded() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    // In production, nonce tracking should use a sliding window or similar
    // to prevent unbounded memory growth. This test verifies the pattern.

    for nonce in 0..10_000u64 {
        let payload = format!("Msg:{}", nonce);
        let envelope = create_valid_envelope(payload.into_bytes(), 8, nonce, &validator);
        let _ = validator.validate(&envelope, &[8]);
    }

    // Check memory usage is bounded
    let nonce_count = validator.seen_nonces.len();

    // NOTE: Current implementation stores all nonces.
    // Production should use sliding window (e.g., only keep last 10 minutes).
    // This test documents the current behavior.
    println!(
        "Nonces tracked: {} (production should use sliding window)",
        nonce_count
    );

    // For now, just verify it didn't panic
    assert!(nonce_count <= 10_000);

    println!("✅ High-volume nonce tracking completed without panic");
}

/// BRUTAL TEST: Empty payload handling
#[test]
fn brutal_empty_payload_handled() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let empty_payload: Vec<u8> = vec![];
    let envelope = create_valid_envelope(empty_payload, 8, 1, &validator);

    // Empty payload should still work (HMAC is valid over empty data)
    let result = validator.validate(&envelope, &[8]);
    assert!(
        result.is_ok(),
        "Empty payload with valid signature should be accepted"
    );

    println!("✅ Empty payload correctly handled");
}

/// BRUTAL TEST: Maximum nonce value
#[test]
fn brutal_max_nonce_value() {
    let shared_secret = [0xAA; 32];
    let mut validator = IpcSecurityValidator::new(shared_secret);

    let payload = b"MaxNonceTest";
    let envelope = create_valid_envelope(payload.to_vec(), 8, u64::MAX, &validator);

    let result = validator.validate(&envelope, &[8]);
    assert!(result.is_ok(), "Maximum nonce value should be accepted");

    // Replay should still be detected
    let replay_result = validator.validate(&envelope, &[8]);
    assert!(
        matches!(
            replay_result,
            Err(IpcSecurityError::ReplayDetected { nonce })
        ),
        "Replay with max nonce should be rejected"
    );

    println!("✅ Maximum nonce value correctly handled");
}
