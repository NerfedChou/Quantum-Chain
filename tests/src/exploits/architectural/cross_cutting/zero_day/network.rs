use super::simple_hash;
use std::collections::{HashMap, HashSet};

// ═══════════════════════════════════════════════════════════════════════════════
//                          QC-01: PEER DISCOVERY HELPERS
// ═══════════════════════════════════════════════════════════════════════════════

#[derive(Clone)]
struct MockNodeInfo {
    node_id: [u8; 32],
    ip: String,
}

struct MockKademliaTable {
    local_id: [u8; 32],
    buckets: Vec<Vec<MockNodeInfo>>,
    k: usize, // max nodes per bucket
}

impl MockKademliaTable {
    fn new(local_id: [u8; 32], k: usize) -> Self {
        Self {
            local_id,
            buckets: vec![Vec::new(); 256],
            k,
        }
    }

    fn xor_distance(&self, id: &[u8; 32]) -> usize {
        // Find first differing bit position
        for (i, (&local_byte, &id_byte)) in self.local_id.iter().zip(id.iter()).enumerate() {
            let xor = local_byte ^ id_byte;
            if xor != 0 {
                return i * 8 + (7 - xor.leading_zeros() as usize);
            }
        }
        255
    }

    fn add_node(&mut self, node: MockNodeInfo) -> Result<(), &'static str> {
        let bucket_idx = self.xor_distance(&node.node_id);
        let bucket = &mut self.buckets[bucket_idx.min(255)];

        if bucket.len() >= self.k {
            return Err("Bucket full");
        }

        bucket.push(node);
        Ok(())
    }

    fn total_nodes(&self) -> usize {
        self.buckets.iter().map(|b| b.len()).sum()
    }

    fn bucket_distribution(&self) -> Vec<usize> {
        self.buckets.iter().map(|b| b.len()).collect()
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
//                          QC-01 & QC-05: NETWORK ATTACKS
// ═══════════════════════════════════════════════════════════════════════════════

#[test]
fn zeroday_qc01_eclipse_via_kademlia_poisoning() {
    let mut table = MockKademliaTable::new([0u8; 32], 20);

    // Attack: Generate 1000 malicious nodes at strategic XOR distances
    let mut malicious_nodes = Vec::new();
    for i in 0u32..1000 {
        let mut node_id = [0u8; 32];
        // Position nodes at various XOR distances to cover all buckets
        let bucket_target = (i % 256) as u8;
        node_id[0] = bucket_target;
        node_id[1] = (i >> 8) as u8;
        node_id[2] = (i >> 16) as u8;

        let node = MockNodeInfo {
            node_id,
            ip: format!("10.0.{}.{}", (i >> 8) & 0xFF, i & 0xFF),
        };
        malicious_nodes.push(node);
    }

    // Attempt to flood the table
    let mut inserted = 0;
    for node in &malicious_nodes {
        if table.add_node(node.clone()).is_ok() {
            inserted += 1;
        }
    }

    let total_nodes = table.total_nodes();
    assert!(
        total_nodes <= 256 * 20,
        "VULNERABILITY: Routing table exceeded max capacity! {} nodes",
        total_nodes
    );

    let bucket_counts = table.bucket_distribution();
    let max_bucket = bucket_counts.iter().max().copied().unwrap_or(0);

    assert!(
        max_bucket <= 20,
        "VULNERABILITY: Bucket overflow! {} nodes in single bucket",
        max_bucket
    );

    println!(
        "✅ Eclipse defense: {} nodes inserted, {} total, max bucket {}",
        inserted, total_nodes, max_bucket
    );
}

#[test]
fn zeroday_qc01_sybil_colluding_node_ids() {
    // Mock for testing Sybil resistance
    struct MockSybilResistantTable {
        nodes_per_subnet: HashMap<String, usize>,
        max_per_subnet: usize,
        total_nodes: usize,
    }

    impl MockSybilResistantTable {
        fn new(max_per_subnet: usize) -> Self {
            Self {
                nodes_per_subnet: HashMap::new(),
                max_per_subnet,
                total_nodes: 0,
            }
        }

        fn add_node(&mut self, ip: &str) -> Result<(), &'static str> {
            // Extract /24 subnet
            let subnet = ip.rsplit_once('.').map(|(s, _)| s).unwrap_or(ip);

            let count = self.nodes_per_subnet.entry(subnet.to_string()).or_insert(0);

            // Defense: Limit nodes per subnet
            if *count >= self.max_per_subnet {
                return Err("Too many nodes from same subnet");
            }

            *count += 1;
            self.total_nodes += 1;
            Ok(())
        }
    }

    let mut table = MockSybilResistantTable::new(5); // Max 5 per /24 subnet

    // Attack: Generate 500 nodes from same /24 subnet
    let mut rejected = 0;
    for i in 0..500u32 {
        let ip = format!("192.168.1.{}", i % 256);
        if table.add_node(&ip).is_err() {
            rejected += 1;
        }
    }

    assert!(
        rejected >= 495,
        "VULNERABILITY: Sybil attack accepted {} nodes from same subnet!",
        500 - rejected
    );

    println!(
        "✅ Sybil defense: {} of 500 same-subnet nodes rejected",
        rejected
    );
}

#[test]
fn zeroday_qc01_node_id_theft() {
    use sha3::{Digest, Keccak256};

    // Defense: Node ID must be cryptographically bound to public key
    fn derive_node_id(public_key: &[u8; 64]) -> [u8; 32] {
        let mut hasher = Keccak256::new();
        hasher.update(public_key);
        let result = hasher.finalize();
        let mut id = [0u8; 32];
        id.copy_from_slice(&result);
        id
    }

    let legitimate_pubkey = [0xAAu8; 64];
    let legitimate_id = derive_node_id(&legitimate_pubkey);

    let attacker_pubkey = [0xBBu8; 64];
    let attacker_id = derive_node_id(&attacker_pubkey);

    assert_ne!(
        legitimate_id, attacker_id,
        "Different keys must produce different IDs"
    );

    println!("✅ Node ID theft requires private key - cryptographically bound");
}

#[test]
fn zeroday_qc05_bandwidth_amplification() {
    struct PropagationTracker {
        pending_requests: HashMap<[u8; 32], HashSet<[u8; 32]>>,
        max_concurrent_requests: usize,
    }

    impl PropagationTracker {
        fn new() -> Self {
            Self {
                pending_requests: HashMap::new(),
                max_concurrent_requests: 10,
            }
        }

        fn request_block(
            &mut self,
            block_hash: [u8; 32],
            peer_id: [u8; 32],
        ) -> Result<(), &'static str> {
            let peers = self.pending_requests.entry(block_hash).or_default();

            if peers.len() >= self.max_concurrent_requests {
                return Err("Too many concurrent requests for this block");
            }

            if !peers.insert(peer_id) {
                return Err("Already requested from this peer");
            }

            Ok(())
        }
    }

    let mut tracker = PropagationTracker::new();
    let target_block = [0xABu8; 32];

    let mut rejected = 0;
    for i in 0..100u8 {
        let mut peer_id = [0u8; 32];
        peer_id[0] = i;

        if tracker.request_block(target_block, peer_id).is_err() {
            rejected += 1;
        }
    }

    assert!(
        rejected >= 90,
        "VULNERABILITY: Only {} requests rejected, amplification possible!",
        rejected
    );

    println!(
        "✅ Bandwidth amplification blocked: {} of 100 requests rejected",
        rejected
    );
}

#[test]
fn zeroday_qc05_gossip_poisoning() {
    struct GossipValidator {
        seen_announcements: HashSet<[u8; 32]>,
        max_announcement_size: usize,
        max_future_blocks: u64,
        current_height: u64,
    }

    impl GossipValidator {
        fn validate_announcement(
            &mut self,
            block_hash: [u8; 32],
            block_height: u64,
            size: usize,
        ) -> Result<(), &'static str> {
            if !self.seen_announcements.insert(block_hash) {
                return Err("Duplicate announcement");
            }

            if size > self.max_announcement_size {
                return Err("Announcement too large");
            }

            if block_height > self.current_height + self.max_future_blocks {
                return Err("Block height too far in future");
            }

            if block_height + 1000 < self.current_height {
                return Err("Block height too far in past");
            }

            Ok(())
        }
    }

    let mut validator = GossipValidator {
        seen_announcements: HashSet::new(),
        max_announcement_size: 1024 * 1024, // 1MB
        max_future_blocks: 100,
        current_height: 10000,
    };

    let attacks = vec![
        ("duplicate", [0xAAu8; 32], 10000, 1000),
        ("duplicate", [0xAAu8; 32], 10000, 1000),
        ("oversized", [0xBBu8; 32], 10000, 10 * 1024 * 1024),
        ("future_block", [0xCCu8; 32], 99999999, 1000),
        ("ancient_block", [0xDDu8; 32], 1, 1000),
    ];

    let mut blocked = 0;
    for (name, hash, height, size) in &attacks {
        let result = validator.validate_announcement(*hash, *height, *size);
        if let Err(e) = result {
            blocked += 1;
            println!("✅ {} blocked: {}", name, e);
        } else {
            println!("⚠️  {} accepted", name);
        }
    }

    assert!(
        blocked >= 4,
        "VULNERABILITY: Only {} attacks blocked!",
        blocked
    );
}
