use super::rand_u64;
use sha3::{Digest, Keccak256};
use std::collections::HashSet;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// ═══════════════════════════════════════════════════════════════════════════════
//                          QC-02: BLOCK STORAGE ATTACKS
// ═══════════════════════════════════════════════════════════════════════════════

#[test]
fn zeroday_qc02_block_hash_collision() {
    // Generate 10000 random "blocks" and check for collisions
    let mut hashes: HashSet<[u8; 32]> = HashSet::new();
    let mut collision_found = false;

    for i in 0u64..10_000 {
        let block_data = format!("block_data_{}_random_{}", i, rand_u64());
        let mut hasher = Keccak256::new();
        hasher.update(block_data.as_bytes());
        let result = hasher.finalize();

        let mut hash = [0u8; 32];
        hash.copy_from_slice(&result);

        if !hashes.insert(hash) {
            collision_found = true;
            break;
        }
    }

    assert!(
        !collision_found,
        "CATASTROPHIC: Hash collision found! Cryptographic failure!"
    );

    println!("✅ No hash collisions in 10,000 blocks (as expected with SHA3-256)");
}

#[test]
fn zeroday_qc02_bit_flip_corruption() {
    // Original block data
    let original_data = b"BLOCK_HEADER:height=1000,parent=0xabc123,merkle=0xdef456";
    let mut corrupted_data = original_data.to_vec();

    // Flip a single bit
    corrupted_data[10] ^= 0x01;

    // Hash both
    let original_hash: [u8; 32] = {
        let mut hasher = Keccak256::new();
        hasher.update(original_data);
        let result = hasher.finalize();
        let mut h = [0u8; 32];
        h.copy_from_slice(&result);
        h
    };

    let corrupted_hash: [u8; 32] = {
        let mut hasher = Keccak256::new();
        hasher.update(&corrupted_data);
        let result = hasher.finalize();
        let mut h = [0u8; 32];
        h.copy_from_slice(&result);
        h
    };

    // Defense: Hash should completely change (avalanche effect)
    assert_ne!(
        original_hash, corrupted_hash,
        "VULNERABILITY: Bit flip didn't change hash!"
    );

    // Count differing bits
    let differing_bits: u32 = original_hash
        .iter()
        .zip(corrupted_hash.iter())
        .map(|(a, b)| (a ^ b).count_ones())
        .sum();

    // Should have ~50% bits different (avalanche)
    assert!(
        differing_bits > 100,
        "Weak avalanche effect: only {} bits differ",
        differing_bits
    );

    println!(
        "✅ Bit flip detection works: {} bits differ in hash",
        differing_bits
    );
}

#[test]
fn zeroday_qc02_assembly_race_condition() {
    // Simulate block assembly state
    struct BlockAssembler {
        transactions: Mutex<Vec<Vec<u8>>>,
        #[allow(dead_code)]
        merkle_root: Mutex<Option<[u8; 32]>>,
        finalized: Mutex<bool>,
    }

    let assembler = Arc::new(BlockAssembler {
        transactions: Mutex::new(Vec::new()),
        merkle_root: Mutex::new(None),
        finalized: Mutex::new(false),
    });

    let race_detected = Arc::new(AtomicUsize::new(0));

    // Thread 1: Adds transactions
    let assembler1 = Arc::clone(&assembler);
    let race1 = Arc::clone(&race_detected);
    let t1 = thread::spawn(move || {
        for i in 0..1000 {
            let mut txs = assembler1.transactions.lock().unwrap();
            let finalized = assembler1.finalized.lock().unwrap();

            // TOCTOU check: Don't add if finalized
            if *finalized {
                race1.fetch_add(1, Ordering::Relaxed);
            } else {
                txs.push(format!("tx_{}", i).into_bytes());
            }
        }
    });

    // Thread 2: Finalizes the block
    let assembler2 = Arc::clone(&assembler);
    let t2 = thread::spawn(move || {
        for _ in 0..100 {
            {
                let mut finalized = assembler2.finalized.lock().unwrap();
                *finalized = true;
            }
            thread::sleep(Duration::from_micros(10));
            {
                let mut finalized = assembler2.finalized.lock().unwrap();
                *finalized = false;
            }
        }
    });

    t1.join().unwrap();
    t2.join().unwrap();

    let races = race_detected.load(Ordering::Relaxed);
    println!(
        "Race condition test: {} potential races detected (with mutex protection)",
        races
    );

    println!("✅ Mutex-based assembly prevents TOCTOU races");
}
