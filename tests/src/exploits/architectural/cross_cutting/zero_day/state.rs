use super::{rand_u64, simple_hash};
use sha3::{Digest, Keccak256};
use std::collections::HashMap;

// ═══════════════════════════════════════════════════════════════════════════════
//                          QC-04: STATE MANAGEMENT HELPERS
// ═══════════════════════════════════════════════════════════════════════════════

struct StateProof {
    path: Vec<u8>,
    value: Vec<u8>,
    siblings: Vec<[u8; 32]>,
}

fn verify_state_proof(
    proof: &StateProof,
    _expected_root: &[u8; 32],
) -> Result<(), &'static str> {
    // Defense 1: Path length validation
    if proof.path.is_empty() {
        return Err("Empty path");
    }
    if proof.path.len() > 64 {
        // Max path length for 256-bit keys
        return Err("Path too long");
    }

    // Defense 2: Path character validation (nibbles only)
    for &nibble in &proof.path {
        if nibble > 15 {
            return Err("Invalid nibble in path");
        }
    }

    // Defense 3: Siblings count must match path length
    if proof.siblings.len() != proof.path.len() {
        return Err("Sibling count mismatch");
    }

    // Defense 4: Value must not be empty for inclusion proofs
    if proof.value.is_empty() {
        return Err("Empty value in inclusion proof");
    }

    Ok(())
}

// ═══════════════════════════════════════════════════════════════════════════════
//                          QC-04 & QC-07: STATE & DATA STRUCTURE ATTACKS
// ═══════════════════════════════════════════════════════════════════════════════

#[test]
fn zeroday_qc04_trie_key_collision() {
    let mut paths: HashMap<Vec<u8>, Vec<u8>> = HashMap::new();
    let mut collision_found = false;

    for i in 0u64..50_000 {
        let key = format!("account_{}", i);
        let key_hash: [u8; 32] = {
            let mut hasher = Keccak256::new();
            hasher.update(key.as_bytes());
            let result = hasher.finalize();
            let mut h = [0u8; 32];
            h.copy_from_slice(&result);
            h
        };

        // Use first 16 bytes as trie path (realistic path length)
        let path = key_hash[..16].to_vec();

        if let Some(existing_key) = paths.get(&path) {
            println!(
                "COLLISION: {} and {} have same path!",
                String::from_utf8_lossy(existing_key),
                key
            );
            collision_found = true;
            break;
        }

        paths.insert(path, key.into_bytes());
    }

    assert!(
        !collision_found,
        "VULNERABILITY: Trie path collision found!"
    );

    println!("✅ No trie key collisions in 50,000 accounts");
}

#[test]
fn zeroday_qc04_state_proof_malformed_path() {
    let malformed_proofs = vec![
        (
            "empty_path",
            StateProof {
                path: vec![],
                value: vec![1, 2, 3],
                siblings: vec![],
            },
        ),
        (
            "oversized_path",
            StateProof {
                path: vec![0; 100],
                value: vec![1, 2, 3],
                siblings: vec![[0u8; 32]; 100],
            },
        ),
        (
            "invalid_nibbles",
            StateProof {
                path: vec![0xFF, 0xAB], // Invalid nibble values
                value: vec![1, 2, 3],
                siblings: vec![[0u8; 32]; 2],
            },
        ),
        (
            "sibling_mismatch",
            StateProof {
                path: vec![1, 2, 3],
                value: vec![1, 2, 3],
                siblings: vec![[0u8; 32]; 5], // Wrong count
            },
        ),
        (
            "empty_value",
            StateProof {
                path: vec![1, 2, 3],
                value: vec![],
                siblings: vec![[0u8; 32]; 3],
            },
        ),
    ];

    let dummy_root = [0u8; 32];
    let mut all_rejected = true;

    for (name, proof) in &malformed_proofs {
        let result = verify_state_proof(proof, &dummy_root);
        if let Err(e) = result {
            println!("✅ {} rejected: {}", name, e);
        } else {
            println!("❌ VULNERABILITY: {} proof accepted!", name);
            all_rejected = false;
        }
    }

    assert!(all_rejected, "Some malformed proofs were accepted!");
}

#[test]
fn zeroday_qc07_bloom_saturation() {
    // Simulate bloom filter
    struct BloomFilter {
        bits: Vec<bool>,
        num_hashes: usize,
        max_elements: usize,
        element_count: usize,
    }

    impl BloomFilter {
        fn new(size: usize, num_hashes: usize, max_elements: usize) -> Self {
            Self {
                bits: vec![false; size],
                num_hashes,
                max_elements,
                element_count: 0,
            }
        }

        fn add(&mut self, item: &[u8]) -> Result<(), &'static str> {
            // Defense: Limit elements
            if self.element_count >= self.max_elements {
                return Err("Filter at capacity");
            }

            // Simple hash simulation
            for i in 0..self.num_hashes {
                let hash = simple_hash(item, i as u8) % self.bits.len();
                self.bits[hash] = true;
            }

            self.element_count += 1;
            Ok(())
        }

        fn saturation(&self) -> f64 {
            let set_bits = self.bits.iter().filter(|&&b| b).count();
            set_bits as f64 / self.bits.len() as f64
        }
    }

    let mut filter = BloomFilter::new(1000, 7, 100);

    // Attack: Try to add 1000 elements
    let mut rejected = 0;
    for i in 0..1000u64 {
        let item = i.to_le_bytes();
        if filter.add(&item).is_err() {
            rejected += 1;
        }
    }

    assert!(
        rejected >= 900,
        "VULNERABILITY: Filter accepted {} elements over limit!",
        1000 - rejected
    );

    let saturation = filter.saturation();
    assert!(
        saturation < 0.7,
        "VULNERABILITY: Filter saturation too high: {:.2}%",
        saturation * 100.0
    );

    println!(
        "✅ Bloom saturation attack blocked: {} rejected, {:.1}% saturated",
        rejected,
        saturation * 100.0
    );
}
