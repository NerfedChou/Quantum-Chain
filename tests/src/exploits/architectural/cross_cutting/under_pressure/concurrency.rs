use super::helpers::create_tx;
use qc_06_mempool::domain::{
    entities::MempoolConfig,
    pool::TransactionPool,
};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Mutex;

/// BRUTAL TEST: Lock starvation attack
///
/// One thread holds lock for extended time, others starve
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn brutal_lock_starvation() {
    let pool = Arc::new(Mutex::new(TransactionPool::new(MempoolConfig::default())));

    let starved_attempts = Arc::new(AtomicUsize::new(0));
    let starved_successes = Arc::new(AtomicUsize::new(0));

    let mut handles = vec![];

    // Hog thread - holds lock for extended periods
    let hog_pool = pool.clone();
    handles.push(tokio::spawn(async move {
        for _ in 0..10 {
            let guard = hog_pool.lock().await;
            // Simulate expensive operation while holding lock
            tokio::time::sleep(Duration::from_millis(50)).await;
            drop(guard);
            tokio::task::yield_now().await;
        }
    }));

    // Victim threads - try to access during hogging
    for victim in 0..5u8 {
        let victim_pool = pool.clone();
        let attempts = starved_attempts.clone();
        let successes = starved_successes.clone();

        handles.push(tokio::spawn(async move {
            for nonce in 0..20u64 {
                attempts.fetch_add(1, Ordering::Relaxed);

                let tx = create_tx(victim, nonce, 1_000_000_000, 1000);
                let result = {
                    let mut guard = victim_pool.lock().await;
                    guard.add(tx)
                };

                if result.is_ok() {
                    successes.fetch_add(1, Ordering::Relaxed);
                }

                tokio::task::yield_now().await;
            }
        }));
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let attempts = starved_attempts.load(Ordering::Relaxed);
    let successes = starved_successes.load(Ordering::Relaxed);

    println!(
        "Lock starvation: {} attempts, {} successes ({:.1}% success rate)",
        attempts,
        successes,
        (successes as f64 / attempts as f64) * 100.0
    );

    // All attempts should eventually succeed (fairness)
    assert!(
        successes > attempts / 2,
        "Too many starved operations: {}/{} succeeded",
        successes,
        attempts
    );

    println!("âœ… Lock fairness maintained under starvation attack");
}
