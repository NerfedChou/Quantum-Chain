use super::helpers::{create_tx, MockMempoolGateway};
use qc_01_peer_discovery::{
    IpAddr, KademliaConfig, NodeId, PeerInfo, RoutingTable, SocketAddr, Timestamp,
};
use qc_06_mempool::domain::{
    entities::MempoolConfig,
    pool::TransactionPool,
};
use qc_10_signature_verification::{
    domain::entities::EcdsaSignature, ports::inbound::SignatureVerificationApi,
    service::SignatureVerificationService,
};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::Mutex;

/// BRUTAL TEST: All three subsystems under simultaneous attack
#[tokio::test(flavor = "multi_thread", worker_threads = 16)]
async fn brutal_multi_vector_attack() {
    // Shared resources
    let mempool = Arc::new(Mutex::new(TransactionPool::new(MempoolConfig {
        max_transactions: 500,
        ..MempoolConfig::default()
    })));

    let routing = Arc::new(Mutex::new(RoutingTable::new(
        NodeId::new([0u8; 32]),
        KademliaConfig::default(),
    )));

    let sig_service = Arc::new(SignatureVerificationService::new(MockMempoolGateway));

    // Metrics
    let mempool_ops = Arc::new(AtomicUsize::new(0));
    let routing_ops = Arc::new(AtomicUsize::new(0));
    let sig_ops = Arc::new(AtomicUsize::new(0));
    let failures = Arc::new(AtomicUsize::new(0));

    let start = Instant::now();
    let duration = Duration::from_secs(3);
    let deadline = start + duration;

    let mut handles = vec![];

    // Mempool attackers (10 threads)
    spawn_mempool_attackers(&mut handles, mempool.clone(), mempool_ops.clone(), deadline);

    // Routing attackers (10 threads)
    spawn_routing_attackers(&mut handles, routing.clone(), routing_ops.clone(), deadline);

    // Signature verification attackers (10 threads)
    spawn_signature_attackers(&mut handles, sig_service.clone(), sig_ops.clone(), deadline);

    // Wait for all attacks
    for handle in handles {
        if handle.await.is_err() {
            failures.fetch_add(1, Ordering::Relaxed);
        }
    }

    let elapsed = start.elapsed();
    let mempool_count = mempool_ops.load(Ordering::Relaxed);
    let routing_count = routing_ops.load(Ordering::Relaxed);
    let sig_count = sig_ops.load(Ordering::Relaxed);
    let failure_count = failures.load(Ordering::Relaxed);

    println!("=== MULTI-VECTOR ATTACK RESULTS ===");
    println!("Duration: {:?}", elapsed);
    println!(
        "Mempool ops: {} ({:.0}/sec)",
        mempool_count,
        mempool_count as f64 / elapsed.as_secs_f64()
    );
    println!(
        "Routing ops: {} ({:.0}/sec)",
        routing_count,
        routing_count as f64 / elapsed.as_secs_f64()
    );
    println!(
        "Sig verify ops: {} ({:.0}/sec)",
        sig_count,
        sig_count as f64 / elapsed.as_secs_f64()
    );
    println!("Task failures: {}", failure_count);

    // Verify system integrity
    {
        let guard = mempool.lock().await;
        assert!(guard.len() <= 500, "Mempool overflow");
    }

    {
        let guard = routing.lock().await;
        let stats = guard.stats(Timestamp::new(10000));
        assert!(stats.total_peers <= 256 * 20, "Routing overflow");
    }

    assert_eq!(failure_count, 0, "Task panics during multi-vector attack");

    println!("âœ… All subsystems survived multi-vector attack");
}

fn spawn_mempool_attackers(
    handles: &mut Vec<tokio::task::JoinHandle<()>>,
    mempool: Arc<Mutex<TransactionPool>>,
    ops: Arc<AtomicUsize>,
    deadline: Instant,
) {
    for attacker in 0..10u8 {
        let pool = mempool.clone();
        let ops = ops.clone();

        handles.push(tokio::spawn(async move {
            let mut nonce = 0u64;
            while Instant::now() < deadline {
                let tx = create_tx(attacker, nonce, 1_000_000_000, 1000);
                {
                    let mut guard = pool.lock().await;
                    let _ = guard.add(tx);
                }
                ops.fetch_add(1, Ordering::Relaxed);
                nonce += 1;

                if nonce % 50 == 0 {
                    tokio::task::yield_now().await;
                }
            }
        }));
    }
}

fn spawn_routing_attackers(
    handles: &mut Vec<tokio::task::JoinHandle<()>>,
    routing: Arc<Mutex<RoutingTable>>,
    ops: Arc<AtomicUsize>,
    deadline: Instant,
) {
    for attacker in 0..10u8 {
        let table = routing.clone();
        let ops = ops.clone();

        handles.push(tokio::spawn(async move {
            let mut i = 0u8;
            while Instant::now() < deadline {
                let mut id = [0u8; 32];
                id[0] = attacker;
                id[1] = i;
                let node_id = NodeId::new(id);

                let peer = PeerInfo::new(
                    node_id,
                    SocketAddr::new(IpAddr::v4(10, attacker, i, 1), 30303),
                    Timestamp::new(1000),
                );

                {
                    let mut guard = table.lock().await;
                    let _ = guard.stage_peer(peer, Timestamp::new(1000));
                    let _ = guard.on_verification_result(&node_id, true, Timestamp::new(1001));
                }

                ops.fetch_add(1, Ordering::Relaxed);
                i = i.wrapping_add(1);

                if i % 50 == 0 {
                    tokio::task::yield_now().await;
                }
            }
        }));
    }
}

fn spawn_signature_attackers(
    handles: &mut Vec<tokio::task::JoinHandle<()>>,
    sig_service: Arc<SignatureVerificationService<MockMempoolGateway>>,
    ops: Arc<AtomicUsize>,
    deadline: Instant,
) {
    for attacker in 0..10u8 {
        let svc = sig_service.clone();
        let ops = ops.clone();

        handles.push(tokio::spawn(async move {
            let mut i = 0u8;
            while Instant::now() < deadline {
                let hash = [attacker ^ i; 32];
                let sig = EcdsaSignature {
                    r: [attacker; 32],
                    s: [i; 32],
                    v: 27,
                };

                let _ = svc.verify_ecdsa(&hash, &sig);
                ops.fetch_add(1, Ordering::Relaxed);
                i = i.wrapping_add(1);
            }
        }));
    }
}
