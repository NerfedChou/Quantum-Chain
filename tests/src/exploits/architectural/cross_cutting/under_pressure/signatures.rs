use super::helpers::MockMempoolGateway;
use qc_10_signature_verification::{
    domain::entities::EcdsaSignature, ports::inbound::SignatureVerificationApi,
    service::SignatureVerificationService,
};
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::Instant;

/// BRUTAL TEST: CPU exhaustion via signature verification
#[tokio::test(flavor = "multi_thread", worker_threads = 16)]
async fn brutal_signature_cpu_exhaustion() {
    let service = Arc::new(SignatureVerificationService::new(MockMempoolGateway));

    let verified = Arc::new(AtomicUsize::new(0));
    let total_time_ns = Arc::new(AtomicU64::new(0));

    let start = Instant::now();
    let mut handles = vec![];

    // 50 threads, each verifying 100 signatures
    for thread in 0..50u8 {
        let svc = service.clone();
        let ver = verified.clone();
        let time = total_time_ns.clone();

        handles.push(tokio::spawn(async move {
            for i in 0..100u8 {
                let mut hash = [0u8; 32];
                hash[0] = thread;
                hash[1] = i;

                let sig = EcdsaSignature {
                    r: [thread; 32],
                    s: [i; 32],
                    v: 27,
                };

                let op_start = Instant::now();
                let _ = svc.verify_ecdsa(&hash, &sig);
                let op_time = op_start.elapsed().as_nanos() as u64;

                time.fetch_add(op_time, Ordering::Relaxed);
                ver.fetch_add(1, Ordering::Relaxed);

                // Don't yield - we want CPU pressure
            }
        }));
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let elapsed = start.elapsed();
    let total_verified = verified.load(Ordering::Relaxed);
    let total_ns = total_time_ns.load(Ordering::Relaxed);
    let avg_ns = total_ns / total_verified as u64;

    println!(
        "CPU exhaustion: {} verifications in {:?}",
        total_verified, elapsed
    );
    println!(
        "Average: {} ns/verification, Throughput: {:.0} verif/sec",
        avg_ns,
        total_verified as f64 / elapsed.as_secs_f64()
    );

    // Should complete all verifications
    assert_eq!(total_verified, 5000, "Lost verifications under load");

    // Should maintain reasonable throughput (at least 1000/sec)
    let throughput = total_verified as f64 / elapsed.as_secs_f64();
    assert!(
        throughput > 1000.0,
        "Throughput too low under load: {:.0} verif/sec",
        throughput
    );

    println!("âœ… Signature verification survived CPU exhaustion");
}
