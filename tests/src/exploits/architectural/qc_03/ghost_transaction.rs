//! # Ghost Transaction Attack (Architectural Exploit)
//!
//! Target: SPEC-06 Mempool Two-Phase Commit

use qc_06_mempool::domain::entities::{MempoolConfig, MempoolTransaction, SignedTransaction, U256};
use qc_06_mempool::domain::pool::TransactionPool;
use std::sync::Arc;
use tokio::sync::Mutex;

fn create_tx(sender_byte: u8, nonce: u64, gas_price: u64) -> MempoolTransaction {
    let signed_tx = SignedTransaction {
        from: [sender_byte; 20],
        to: Some([0xBB; 20]),
        value: U256::zero(),
        nonce,
        gas_price: U256::from(gas_price),
        gas_limit: 21000,
        data: vec![],
        signature: [0u8; 64],
    };
    MempoolTransaction::new(signed_tx, 1000)
}

/// Test: Ghost transaction attack - concurrent version
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn test_ghost_transaction_concurrent() {
    let config = MempoolConfig {
        max_transactions: 100,
        max_per_account: 100,
        pending_inclusion_timeout_ms: 500,
        ..MempoolConfig::default()
    };
    let pool = Arc::new(Mutex::new(TransactionPool::new(config)));

    // Phase 1: Fill the pool
    let mut first_batch = vec![];
    {
        let mut guard = pool.lock().await;
        for i in 0..100u8 {
            let tx = create_tx(i, 0, 1_000_000_000);
            first_batch.push(tx.hash);
            guard.add(tx).unwrap();
        }
        assert_eq!(guard.len(), 100, "Pool should be full");
    }

    // Phase 2: Evil proposer moves ALL to PendingInclusion
    {
        let mut guard = pool.lock().await;
        let result = guard.propose(&first_batch, 1, 1000);
        assert_eq!(result.proposed_count, 100);

        assert_eq!(guard.pending_count(), 0, "No pending after propose");
        assert_eq!(
            guard.pending_inclusion_count(),
            100,
            "All pending_inclusion"
        );
        assert_eq!(guard.len(), 100, "len() should include pending_inclusion");
    }

    // Phase 3: Attacker tries to add MORE transactions
    let mut second_batch_added = 0;
    {
        let mut guard = pool.lock().await;
        for i in 100..200u8 {
            let tx = create_tx(i, 0, 2_000_000_000);
            if guard.add(tx).is_ok() {
                second_batch_added += 1;
            }
        }
    }

    // Check: Did we exceed the limit?
    {
        let guard = pool.lock().await;
        let total = guard.len();

        println!(
            "After ghost attack: first_batch=100 (pending_inclusion), second_batch={}, total={}",
            second_batch_added, total
        );

        if total > 100 {
            println!(
                "❌ CRITICAL VULNERABILITY: Pool has {} txs (limit: 100)!",
                total
            );
        } else {
            println!("✅ DEFENDED: Pool respects limit including pending_inclusion");
        }

        assert!(
            total <= 100,
            "Ghost Transaction Attack succeeded! Pool has {} txs",
            total
        );
    }

    // Phase 4: Simulate timeout rollback
    tokio::time::sleep(tokio::time::Duration::from_millis(600)).await;

    {
        let mut guard = pool.lock().await;
        let rolled_back = guard.cleanup_timeouts(2000);

        println!(
            "Timeout rollback: {} transactions restored",
            rolled_back.len()
        );

        assert!(
            guard.pending_count() > 0 || rolled_back.len() > 0,
            "Rollback didn't restore pending status"
        );
    }
}

/// Test: Double-spend via propose timing
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_double_spend_via_propose_timing() {
    let config = MempoolConfig {
        max_transactions: 100,
        enable_rbf: true,
        rbf_min_bump_percent: 10,
        ..MempoolConfig::default()
    };
    let pool = Arc::new(Mutex::new(TransactionPool::new(config)));

    let original = create_tx(0xAA, 0, 1_000_000_000);
    let original_hash = original.hash;

    {
        let mut guard = pool.lock().await;
        guard.add(original).unwrap();
    }

    {
        let mut guard = pool.lock().await;
        guard.propose(&[original_hash], 1, 1000);
        assert!(guard.get(&original_hash).unwrap().is_pending_inclusion());
    }

    let replacement = create_tx(0xAA, 0, 2_000_000_000);

    {
        let mut guard = pool.lock().await;
        let result = guard.add(replacement);

        if result.is_ok() {
            println!("❌ VULNERABILITY: Replaced pending_inclusion transaction!");
        } else {
            println!("✅ Cannot replace pending_inclusion transaction");
        }

        assert!(
            result.is_err(),
            "Double-spend via RBF on pending_inclusion should be rejected"
        );
    }
}

/// Test: Orphaned pending_inclusion recovery
#[tokio::test]
async fn test_orphaned_pending_inclusion_recovery() {
    let config = MempoolConfig {
        max_transactions: 50,
        pending_inclusion_timeout_ms: 200,
        ..MempoolConfig::default()
    };
    let mut pool = TransactionPool::new(config);

    let mut hashes = vec![];
    for i in 0..20u8 {
        let tx = create_tx(i, 0, 1_000_000_000);
        hashes.push(tx.hash);
        pool.add(tx).unwrap();
    }

    pool.propose(&hashes, 1, 0);

    assert_eq!(pool.pending_inclusion_count(), 20);
    assert_eq!(pool.pending_count(), 0);

    tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;

    let recovered = pool.cleanup_timeouts(300);

    println!("Recovered {} orphaned transactions", recovered.len());

    assert_eq!(recovered.len(), 20, "All orphaned txs should be recovered");
    assert_eq!(pool.pending_count(), 20, "Recovered txs should be pending");
    assert_eq!(
        pool.pending_inclusion_count(),
        0,
        "No more pending_inclusion"
    );

    let batch = pool.get_for_block(20, u64::MAX);
    assert_eq!(batch.len(), 20, "Recovered txs should be selectable");

    println!("✅ Orphaned pending_inclusion transactions recovered successfully");
}
