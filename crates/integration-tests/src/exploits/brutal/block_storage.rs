//! # Brutal Tests: Block Storage (qc-02)
//!
//! Security exploit tests for the Block Storage Engine using the REAL implementation.
//!
//! ## Architecture Context (V2.3 Choreography)
//!
//! Block Storage is a **Stateful Assembler** that:
//! - Subscribes to THREE independent events (BlockValidated, MerkleRootComputed, StateRootComputed)
//! - Buffers partial assemblies by block_hash
//! - Performs atomic write when all 3 components arrive
//! - Purges incomplete assemblies after timeout (INVARIANT-7)
//!
//! ## Attack Vectors Tested
//!
//! ### Assembler Attacks (INVARIANT-7, 8)
//! - Zombie Assembler: Send only partial events to exhaust memory
//! - Memory Bomb: Flood with max_pending_assemblies + N partial blocks
//! - Event Order Manipulation: Send events out of order
//!
//! ### Integrity Attacks (INVARIANT-3, 4)
//! - Checksum Bypass: Corrupt stored data, verify detection
//! - Partial Write: Simulate crash mid-batch, verify rollback
//!
//! ### Capacity Attacks (INVARIANT-1, 2)
//! - Disk Exhaustion: Write when disk < 5%
//! - Parent Bypass: Write block without parent existing
//!
//! ### Finality Attacks (INVARIANT-5, 6)
//! - Finalization Regression: Finalize lower height after higher
//! - Genesis Mutation: Attempt to change genesis hash
//!
//! ### Authorization Attacks (IPC-MATRIX)
//! - Sender Spoofing: Non-authorized subsystem sends events
//!
//! ## Reference Documents
//! - SPEC-02-BLOCK-STORAGE.md v2.3
//! - Architecture.md Section 5.1 (Choreography Pattern)
//! - IPC-MATRIX.md Subsystem 2 section

use std::sync::{Arc, Mutex};

// Import REAL qc-02 types
use qc_02_block_storage::ports::inbound::BlockAssemblerApi;
use qc_02_block_storage::ports::outbound::{
    BincodeBlockSerializer, DefaultChecksumProvider, InMemoryKVStore, MockFileSystemAdapter,
    SystemTimeSource,
};
use qc_02_block_storage::service::subsystem_ids;
use qc_02_block_storage::{
    AssemblyConfig, BlockAssemblyBuffer, BlockStorageApi, BlockStorageService, StorageConfig,
    StorageError,
};
use shared_types::{BlockHeader, ConsensusProof, Hash, ValidatedBlock};

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/// Create a test service with full disk space
fn make_test_service() -> BlockStorageService<
    InMemoryKVStore,
    MockFileSystemAdapter,
    DefaultChecksumProvider,
    SystemTimeSource,
    BincodeBlockSerializer,
> {
    BlockStorageService::new(
        InMemoryKVStore::new(),
        MockFileSystemAdapter::new(50), // 50% disk space
        DefaultChecksumProvider,
        SystemTimeSource,
        BincodeBlockSerializer,
        StorageConfig::default(),
    )
}

/// Create a test service with specific disk space
fn make_service_with_disk_space(
    percent: u8,
) -> BlockStorageService<
    InMemoryKVStore,
    MockFileSystemAdapter,
    DefaultChecksumProvider,
    SystemTimeSource,
    BincodeBlockSerializer,
> {
    BlockStorageService::new(
        InMemoryKVStore::new(),
        MockFileSystemAdapter::new(percent),
        DefaultChecksumProvider,
        SystemTimeSource,
        BincodeBlockSerializer,
        StorageConfig::default(),
    )
}

/// Create a test service with custom assembly config
fn make_service_with_assembly_config(
    config: AssemblyConfig,
) -> BlockStorageService<
    InMemoryKVStore,
    MockFileSystemAdapter,
    DefaultChecksumProvider,
    SystemTimeSource,
    BincodeBlockSerializer,
> {
    let mut storage_config = StorageConfig::default();
    storage_config.assembly_config = config;
    BlockStorageService::new(
        InMemoryKVStore::new(),
        MockFileSystemAdapter::new(50),
        DefaultChecksumProvider,
        SystemTimeSource,
        BincodeBlockSerializer,
        storage_config,
    )
}

/// Create a validated block for testing
fn make_test_block(height: u64, parent_hash: Hash) -> ValidatedBlock {
    ValidatedBlock {
        header: BlockHeader {
            version: 1,
            height,
            parent_hash,
            merkle_root: [0; 32],
            state_root: [0; 32],
            timestamp: 1000 + height,
            proposer: [0xAA; 32],
            difficulty: shared_types::U256::from(2).pow(shared_types::U256::from(252)),
            nonce: 0,
        },
        transactions: vec![],
        consensus_proof: ConsensusProof {
            block_hash: [height as u8; 32],
            attestations: vec![],
            total_stake: 0,
        },
    }
}

/// Compute block hash (same as service does)
fn compute_block_hash(block: &ValidatedBlock) -> Hash {
    use k256::sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    hasher.update(&block.header.parent_hash);
    hasher.update(&block.header.height.to_le_bytes());
    hasher.update(&block.header.merkle_root);
    hasher.update(&block.header.state_root);
    hasher.update(&block.header.timestamp.to_le_bytes());
    hasher.finalize().into()
}

// =============================================================================
// BRUTAL TESTS: ASSEMBLER ATTACKS (INVARIANT-7, 8)
// =============================================================================

/// BRUTAL TEST: Zombie Assembler Attack
///
/// Attack: Send only BlockValidated events via choreography, never send merkle/state roots.
/// This should cause assemblies to timeout and be purged (INVARIANT-7).
///
/// Defense: Assembly timeout after 30 seconds prevents memory exhaustion.
#[test]
fn brutal_zombie_assembler_attack() {
    let config = AssemblyConfig {
        assembly_timeout_secs: 30,
        max_pending_assemblies: 1000,
    };
    let mut buffer = BlockAssemblyBuffer::new(config);

    // Send 100 BlockValidated events (zombie assemblies)
    for i in 0..100u64 {
        let block = make_test_block(i, [0; 32]);
        let block_hash = compute_block_hash(&block);
        buffer.add_block_validated(block_hash, block, 1000);
    }

    assert_eq!(buffer.len(), 100, "Should have 100 pending assemblies");

    // Time passes... 31 seconds later
    let expired = buffer.gc_expired(1000 + 31);

    assert_eq!(
        expired.len(),
        100,
        "All 100 assemblies should expire after timeout"
    );
    assert_eq!(buffer.len(), 0, "Buffer should be empty after GC");

    println!("✅ REAL qc-02: Zombie assemblies correctly purged after timeout");
}

/// BRUTAL TEST: Memory Bomb Attack
///
/// Attack: Flood with max_pending_assemblies + 100 partial blocks.
/// This should trigger the bounded buffer enforcement (INVARIANT-8).
///
/// Defense: Oldest assemblies are purged when limit exceeded.
#[test]
fn brutal_memory_bomb_attack() {
    let config = AssemblyConfig {
        assembly_timeout_secs: 30,
        max_pending_assemblies: 100, // Low limit for testing
    };
    let mut buffer = BlockAssemblyBuffer::new(config);

    // Send 200 partial assemblies (double the limit)
    for i in 0..200u64 {
        let block = make_test_block(i, [0; 32]);
        let block_hash = compute_block_hash(&block);
        // Stagger timestamps so we can identify oldest
        buffer.add_block_validated(block_hash, block, 1000 + i);
    }

    assert_eq!(
        buffer.len(),
        200,
        "Should have 200 pending assemblies before enforcement"
    );

    // Enforce limit
    let purged = buffer.enforce_max_pending();

    assert_eq!(purged.len(), 100, "Should purge 100 oldest assemblies");
    assert_eq!(
        buffer.len(),
        100,
        "Should have exactly max_pending_assemblies"
    );

    println!("✅ REAL qc-02: Memory bomb correctly bounded to max_pending_assemblies");
}

/// BRUTAL TEST: Assembly Completes When All Three Arrive (V2.3 Choreography)
///
/// Verify: The choreography pattern works via the real service.
#[test]
fn brutal_assembly_completes_with_all_three() {
    let mut service = make_test_service();
    let block = make_test_block(0, [0; 32]);
    let block_hash = compute_block_hash(&block);
    let now = 1000;

    // Send BlockValidated from Consensus (8)
    service
        .on_block_validated(subsystem_ids::CONSENSUS, block.clone(), now)
        .unwrap();

    // Block not written yet (need merkle + state)
    assert!(
        !service.block_exists_at_height(0),
        "Block should not exist yet"
    );

    // Send MerkleRootComputed from Transaction Indexing (3)
    service
        .on_merkle_root_computed(
            subsystem_ids::TRANSACTION_INDEXING,
            block_hash,
            [0xAA; 32],
            now,
        )
        .unwrap();

    // Still not written
    assert!(
        !service.block_exists_at_height(0),
        "Block should still not exist"
    );

    // Send StateRootComputed from State Management (4)
    service
        .on_state_root_computed(subsystem_ids::STATE_MANAGEMENT, block_hash, [0xBB; 32], now)
        .unwrap();

    // NOW it should be written!
    assert!(
        service.block_exists_at_height(0),
        "Block should now exist after all three events"
    );

    println!("✅ REAL qc-02: Assembly correctly completes when all three events arrive");
}

/// BRUTAL TEST: Assembly Works Regardless of Event Order (V2.3 Choreography)
///
/// Verify: Events can arrive in any order - StateRoot first, then MerkleRoot, then BlockValidated.
#[test]
fn brutal_assembly_any_order() {
    let mut service = make_test_service();
    let block = make_test_block(0, [0; 32]);
    let block_hash = compute_block_hash(&block);
    let now = 1000;

    // Order: StateRoot → MerkleRoot → BlockValidated (reverse of normal)
    service
        .on_state_root_computed(subsystem_ids::STATE_MANAGEMENT, block_hash, [0xBB; 32], now)
        .unwrap();
    assert!(!service.block_exists_at_height(0));

    service
        .on_merkle_root_computed(
            subsystem_ids::TRANSACTION_INDEXING,
            block_hash,
            [0xAA; 32],
            now,
        )
        .unwrap();
    assert!(!service.block_exists_at_height(0));

    service
        .on_block_validated(subsystem_ids::CONSENSUS, block, now)
        .unwrap();
    assert!(
        service.block_exists_at_height(0),
        "Block should exist after all events (any order)"
    );

    println!("✅ REAL qc-02: Assembly works regardless of event order");
}

// =============================================================================
// BRUTAL TESTS: CAPACITY ATTACKS (INVARIANT-1, 2)
// =============================================================================

/// BRUTAL TEST: Disk Exhaustion Attack
///
/// Attack: Fill disk to < 5% and attempt writes.
/// Defense: Write fails with DiskFull error (INVARIANT-2).
#[test]
fn brutal_disk_exhaustion_attack() {
    let mut service = make_service_with_disk_space(4); // Below 5% threshold

    let block = make_test_block(0, [0; 32]);
    let result = service.write_block(block, [0x02; 32], [0x03; 32]);

    assert!(
        matches!(
            result,
            Err(StorageError::DiskFull {
                available_percent: 4,
                ..
            })
        ),
        "Write should fail when disk < 5%"
    );

    println!("✅ REAL qc-02: Disk exhaustion correctly prevents writes");
}

/// BRUTAL TEST: Boundary Disk Space (Exactly 5%)
///
/// Verify: At exactly 5%, writes should succeed.
#[test]
fn brutal_disk_space_boundary() {
    let mut service = make_service_with_disk_space(5); // Exactly 5%

    let block = make_test_block(0, [0; 32]);
    let result = service.write_block(block, [0x02; 32], [0x03; 32]);

    assert!(
        result.is_ok(),
        "Write should succeed at exactly 5% disk space"
    );

    println!("✅ REAL qc-02: Disk space boundary (5%) correctly enforced");
}

/// BRUTAL TEST: Parent Block Missing Attack
///
/// Attack: Write block at height 5 without any parent blocks.
/// Defense: Write fails with ParentNotFound (INVARIANT-1).
#[test]
fn brutal_parent_missing_attack() {
    let mut service = make_test_service();

    // Try to write block at height 5 with no genesis
    let block = make_test_block(5, [0xFF; 32]); // Non-existent parent

    let result = service.write_block(block, [0x02; 32], [0x03; 32]);

    assert!(
        matches!(result, Err(StorageError::ParentNotFound { .. })),
        "Write should fail when parent doesn't exist"
    );

    println!("✅ REAL qc-02: Parent block requirement correctly enforced");
}

/// BRUTAL TEST: Genesis Block Has No Parent Requirement
///
/// Verify: Block at height 0 (genesis) doesn't require a parent.
#[test]
fn brutal_genesis_no_parent_requirement() {
    let mut service = make_test_service();

    let genesis = make_test_block(0, [0xFF; 32]); // Parent hash is ignored for genesis
    let result = service.write_block(genesis, [0x02; 32], [0x03; 32]);

    assert!(result.is_ok(), "Genesis block should not require parent");
    assert!(service.block_exists_at_height(0));

    println!("✅ REAL qc-02: Genesis block correctly has no parent requirement");
}

/// BRUTAL TEST: Sequential Block Chain Build
///
/// Verify: Can build a chain where each block references its parent.
#[test]
fn brutal_sequential_chain_build() {
    let mut service = make_test_service();

    // Build a chain of 10 blocks
    let mut parent_hash = [0; 32];
    for height in 0..10 {
        let block = make_test_block(height, parent_hash);
        parent_hash = service
            .write_block(block, [0x02; 32], [0x03; 32])
            .expect(&format!("Block {} should be written successfully", height));
    }

    assert_eq!(service.get_latest_height().unwrap(), 9);

    println!("✅ REAL qc-02: Sequential chain of 10 blocks built successfully");
}

// =============================================================================
// BRUTAL TESTS: FINALITY ATTACKS (INVARIANT-5, 6)
// =============================================================================

/// BRUTAL TEST: Finalization Regression Attack
///
/// Attack: Finalize height 5, then try to finalize height 3.
/// Defense: Finalization is monotonic (INVARIANT-5).
#[test]
fn brutal_finalization_regression_attack() {
    let mut service = make_test_service();

    // Build chain of 10 blocks
    let mut parent_hash = [0; 32];
    for height in 0..10 {
        let block = make_test_block(height, parent_hash);
        parent_hash = service.write_block(block, [0x02; 32], [0x03; 32]).unwrap();
    }

    // Finalize height 5
    service.mark_finalized(5).unwrap();
    assert_eq!(service.get_finalized_height().unwrap(), 5);

    // Attack: Try to regress to height 3
    let result = service.mark_finalized(3);
    assert!(
        matches!(
            result,
            Err(StorageError::InvalidFinalization {
                requested: 3,
                current: 5
            })
        ),
        "Finalization regression should fail"
    );

    // Same height should also fail
    let result2 = service.mark_finalized(5);
    assert!(
        matches!(
            result2,
            Err(StorageError::InvalidFinalization {
                requested: 5,
                current: 5
            })
        ),
        "Re-finalizing same height should fail"
    );

    // Higher height should succeed
    service.mark_finalized(7).unwrap();
    assert_eq!(service.get_finalized_height().unwrap(), 7);

    println!("✅ REAL qc-02: Finalization monotonicity correctly enforced");
}

/// BRUTAL TEST: Finalize Non-Existent Block
///
/// Attack: Try to finalize a height that doesn't exist.
/// Defense: Block must exist before finalization.
#[test]
fn brutal_finalize_nonexistent_block() {
    let mut service = make_test_service();

    // Only write genesis
    let genesis = make_test_block(0, [0; 32]);
    service
        .write_block(genesis, [0x02; 32], [0x03; 32])
        .unwrap();

    // Try to finalize height 10 (doesn't exist)
    let result = service.mark_finalized(10);
    assert!(
        matches!(result, Err(StorageError::HeightNotFound { height: 10 })),
        "Finalizing non-existent height should fail"
    );

    println!("✅ REAL qc-02: Cannot finalize non-existent block");
}

// =============================================================================
// BRUTAL TESTS: AUTHORIZATION ATTACKS (IPC-MATRIX)
// =============================================================================

/// BRUTAL TEST: Unauthorized BlockValidated Sender
///
/// Attack: Non-Consensus subsystem sends BlockValidated event.
/// Defense: Only Subsystem 8 (Consensus) can send BlockValidated.
#[test]
fn brutal_unauthorized_block_validated_sender() {
    let mut service = make_test_service();
    let block = make_test_block(0, [0; 32]);
    let now = 1000;

    // Test all unauthorized senders
    let unauthorized_senders = vec![
        (subsystem_ids::TRANSACTION_INDEXING, "TransactionIndexing"),
        (subsystem_ids::STATE_MANAGEMENT, "StateManagement"),
        (subsystem_ids::FINALITY, "Finality"),
        (subsystem_ids::BLOCK_STORAGE, "BlockStorage"),
    ];

    for (sender_id, name) in unauthorized_senders {
        let result = service.on_block_validated(sender_id, block.clone(), now);
        assert!(
            matches!(result, Err(StorageError::UnauthorizedSender { .. })),
            "BlockValidated from {} should be rejected",
            name
        );
    }

    // Consensus should succeed
    let consensus_result = service.on_block_validated(subsystem_ids::CONSENSUS, block, now);
    assert!(
        consensus_result.is_ok(),
        "BlockValidated from Consensus should be accepted"
    );

    println!("✅ REAL qc-02: BlockValidated sender verification correctly enforced");
}

/// BRUTAL TEST: Unauthorized MerkleRootComputed Sender
///
/// Attack: Non-TransactionIndexing subsystem sends MerkleRootComputed.
/// Defense: Only Subsystem 3 (Transaction Indexing) can send MerkleRootComputed.
#[test]
fn brutal_unauthorized_merkle_root_sender() {
    let mut service = make_test_service();
    let block_hash = [0xAB; 32];
    let now = 1000;

    let unauthorized_senders = vec![
        (subsystem_ids::CONSENSUS, "Consensus"),
        (subsystem_ids::STATE_MANAGEMENT, "StateManagement"),
        (subsystem_ids::FINALITY, "Finality"),
    ];

    for (sender_id, name) in unauthorized_senders {
        let result = service.on_merkle_root_computed(sender_id, block_hash, [0xCC; 32], now);
        assert!(
            matches!(result, Err(StorageError::UnauthorizedSender { .. })),
            "MerkleRootComputed from {} should be rejected",
            name
        );
    }

    // Transaction Indexing should succeed
    let tx_result = service.on_merkle_root_computed(
        subsystem_ids::TRANSACTION_INDEXING,
        block_hash,
        [0xCC; 32],
        now,
    );
    assert!(tx_result.is_ok());

    println!("✅ REAL qc-02: MerkleRootComputed sender verification correctly enforced");
}

/// BRUTAL TEST: Unauthorized StateRootComputed Sender
///
/// Attack: Non-StateManagement subsystem sends StateRootComputed.
/// Defense: Only Subsystem 4 (State Management) can send StateRootComputed.
#[test]
fn brutal_unauthorized_state_root_sender() {
    let mut service = make_test_service();
    let block_hash = [0xAB; 32];
    let now = 1000;

    let unauthorized_senders = vec![
        (subsystem_ids::CONSENSUS, "Consensus"),
        (subsystem_ids::TRANSACTION_INDEXING, "TransactionIndexing"),
        (subsystem_ids::FINALITY, "Finality"),
    ];

    for (sender_id, name) in unauthorized_senders {
        let result = service.on_state_root_computed(sender_id, block_hash, [0xDD; 32], now);
        assert!(
            matches!(result, Err(StorageError::UnauthorizedSender { .. })),
            "StateRootComputed from {} should be rejected",
            name
        );
    }

    // State Management should succeed
    let state_result = service.on_state_root_computed(
        subsystem_ids::STATE_MANAGEMENT,
        block_hash,
        [0xDD; 32],
        now,
    );
    assert!(state_result.is_ok());

    println!("✅ REAL qc-02: StateRootComputed sender verification correctly enforced");
}

// =============================================================================
// BRUTAL TESTS: INTEGRITY ATTACKS (INVARIANT-3)
// =============================================================================

/// BRUTAL TEST: Block Read Validates Checksum
///
/// Verify: Every read operation validates the stored checksum.
#[test]
fn brutal_block_read_validates_checksum() {
    let mut service = make_test_service();

    // Write a valid block
    let block = make_test_block(0, [0; 32]);
    let hash = service.write_block(block, [0xAA; 32], [0xBB; 32]).unwrap();

    // Read should succeed - checksum is valid
    let result = service.read_block(&hash);
    assert!(result.is_ok(), "Valid block read should succeed");

    println!("✅ REAL qc-02: Block read validates checksum on every read");
}

/// BRUTAL TEST: Duplicate Block Write Rejected
///
/// Verify: Cannot write the same block twice.
#[test]
fn brutal_duplicate_block_write_rejected() {
    let mut service = make_test_service();

    let block = make_test_block(0, [0; 32]);

    // First write succeeds
    let hash = service
        .write_block(block.clone(), [0xAA; 32], [0xBB; 32])
        .unwrap();

    // Second write with same block should fail
    let result = service.write_block(block, [0xAA; 32], [0xBB; 32]);
    assert!(matches!(result, Err(StorageError::BlockExists { .. })));

    println!("✅ REAL qc-02: Duplicate block write correctly rejected");
}

// =============================================================================
// BRUTAL TESTS: BATCH READ ATTACKS
// =============================================================================

/// BRUTAL TEST: Batch Read Respects Limit Cap (100)
///
/// Attack: Request 500 blocks in a single batch.
/// Defense: Limit is capped at 100 per IPC-MATRIX.
#[test]
fn brutal_batch_read_limit_cap() {
    let mut service = make_test_service();

    // Write 150 blocks
    let mut parent_hash = [0; 32];
    for height in 0..150 {
        let block = make_test_block(height, parent_hash);
        parent_hash = service.write_block(block, [0; 32], [0; 32]).unwrap();
    }

    // Request 500 blocks - should be capped at 100
    let blocks = service.read_block_range(0, 500).unwrap();
    assert_eq!(blocks.len(), 100, "Batch read should be capped at 100");

    println!("✅ REAL qc-02: Batch read correctly capped at 100 blocks");
}

/// BRUTAL TEST: Batch Read Returns Partial At Chain End
///
/// Verify: Returns fewer blocks if chain ends before limit.
#[test]
fn brutal_batch_read_partial_chain() {
    let mut service = make_test_service();

    // Write only 10 blocks (0-9)
    let mut parent_hash = [0; 32];
    for height in 0..10 {
        let block = make_test_block(height, parent_hash);
        parent_hash = service.write_block(block, [0; 32], [0; 32]).unwrap();
    }

    // Request 20 blocks starting at height 5
    let blocks = service.read_block_range(5, 20).unwrap();

    // Should only get blocks 5-9 (5 blocks)
    assert_eq!(blocks.len(), 5, "Should return only available blocks");

    println!("✅ REAL qc-02: Batch read correctly returns partial at chain end");
}

// =============================================================================
// BRUTAL TESTS: CONCURRENT ATTACKS
// =============================================================================

/// BRUTAL TEST: Concurrent Assembly Buffer Access
///
/// Verify: Multiple threads can safely add to assembly buffer.
#[test]
fn brutal_concurrent_assembly_access() {
    use std::thread;

    let buffer = Arc::new(Mutex::new(BlockAssemblyBuffer::new(
        AssemblyConfig::default(),
    )));
    let mut handles = vec![];

    // Spawn 10 threads, each adding 10 assemblies
    for thread_id in 0..10u64 {
        let buffer_clone = Arc::clone(&buffer);
        let handle = thread::spawn(move || {
            for i in 0..10u64 {
                let block = make_test_block(thread_id * 10 + i, [0; 32]);
                let block_hash = compute_block_hash(&block);

                let mut buffer = buffer_clone.lock().unwrap();
                buffer.add_block_validated(block_hash, block, 1000);
            }
        });
        handles.push(handle);
    }

    // Wait for all threads
    for handle in handles {
        handle.join().unwrap();
    }

    let final_buffer = buffer.lock().unwrap();
    assert_eq!(
        final_buffer.len(),
        100,
        "Should have 100 assemblies from 10 threads x 10 each"
    );

    println!("✅ REAL qc-02: Concurrent assembly buffer access is thread-safe");
}

// =============================================================================
// BRUTAL TESTS: CHOREOGRAPHY STRESS TESTS
// =============================================================================

/// BRUTAL TEST: Full V2.3 Choreography Flow
///
/// Verify: Complete flow from 3 subsystems results in stored block.
#[test]
fn brutal_full_choreography_flow() {
    let mut service = make_test_service();

    // Build a chain of 5 blocks via choreography
    for height in 0..5u64 {
        let parent_hash = if height == 0 {
            [0; 32]
        } else {
            // Get parent from previous height
            let parent = service.read_block_by_height(height - 1).unwrap();
            parent.block_hash()
        };

        let block = make_test_block(height, parent_hash);
        let block_hash = compute_block_hash(&block);
        let now = 1000 + height;

        // Simulate events from 3 different subsystems
        service
            .on_block_validated(subsystem_ids::CONSENSUS, block, now)
            .unwrap();
        service
            .on_merkle_root_computed(
                subsystem_ids::TRANSACTION_INDEXING,
                block_hash,
                [0xAA; 32],
                now,
            )
            .unwrap();
        service
            .on_state_root_computed(subsystem_ids::STATE_MANAGEMENT, block_hash, [0xBB; 32], now)
            .unwrap();

        assert!(
            service.block_exists_at_height(height),
            "Block {} should exist",
            height
        );
    }

    assert_eq!(service.get_latest_height().unwrap(), 4);

    println!("✅ REAL qc-02: Full V2.3 choreography flow works for chain of 5 blocks");
}
