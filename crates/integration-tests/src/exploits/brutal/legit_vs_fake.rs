//! # Legit vs Fake: Spoofing Detection Tests
//!
//! Can the system distinguish legitimate requests from forgeries?
//!
//! ## Attack Vectors:
//! 1. Signature forgery - Invalid cryptographic proofs
//! 2. Identity spoofing - Fake NodeIds claiming to be trusted peers
//! 3. Transaction replay - Reusing valid signatures for different messages
//! 4. Man-in-the-middle - Modified transactions with original signatures

use qc_01_peer_discovery::{
    IpAddr, KademliaConfig, NodeId, PeerInfo, RoutingTable, SocketAddr, Timestamp,
};
use qc_06_mempool::domain::{
    entities::{MempoolConfig, MempoolTransaction, SignedTransaction, U256},
    pool::TransactionPool,
};
use qc_10_signature_verification::{
    domain::entities::EcdsaSignature, ports::inbound::SignatureVerificationApi,
    service::SignatureVerificationService,
};
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Clone)]
struct MockMempoolGateway;

#[async_trait::async_trait]
impl qc_10_signature_verification::ports::outbound::MempoolGateway for MockMempoolGateway {
    async fn submit_verified_transaction(
        &self,
        _tx: qc_10_signature_verification::domain::entities::VerifiedTransaction,
    ) -> Result<(), qc_10_signature_verification::ports::outbound::MempoolError> {
        Ok(())
    }
}

// ============================================================================
// SIGNATURE FORGERY TESTS
// ============================================================================

/// BRUTAL TEST: Signature with flipped bits
///
/// Attack: Take a valid-looking signature and flip random bits.
/// Every bit position should cause rejection.
#[test]
fn brutal_signature_every_bit_flip_rejected() {
    let service = SignatureVerificationService::new(MockMempoolGateway);
    let message_hash = [0xAB; 32];

    // Base signature (will be invalid anyway, but we want consistent rejections)
    let base_sig = EcdsaSignature {
        r: [0x12; 32],
        s: [0x34; 32],
        v: 27,
    };

    let mut all_rejected = true;
    let mut accepted_positions = Vec::new();

    // Test flipping each bit in R
    for byte_idx in 0..32 {
        for bit_idx in 0..8 {
            let mut flipped_r = base_sig.r;
            flipped_r[byte_idx] ^= 1 << bit_idx;

            let sig = EcdsaSignature {
                r: flipped_r,
                s: base_sig.s,
                v: 27,
            };

            let result = service.verify_ecdsa(&message_hash, &sig);
            if result.valid {
                all_rejected = false;
                accepted_positions.push(format!("r[{:?}].bit{:?}", byte_idx, bit_idx));
            }
        }
    }

    // Test flipping each bit in S
    for byte_idx in 0..32 {
        for bit_idx in 0..8 {
            let mut flipped_s = base_sig.s;
            flipped_s[byte_idx] ^= 1 << bit_idx;

            let sig = EcdsaSignature {
                r: base_sig.r,
                s: flipped_s,
                v: 27,
            };

            let result = service.verify_ecdsa(&message_hash, &sig);
            if result.valid {
                all_rejected = false;
                accepted_positions.push(format!("s[{:?}].bit{:?}", byte_idx, bit_idx));
            }
        }
    }

    // Test V values
    for v in [0, 1, 26, 28, 29, 30, 35, 36, 255] {
        let sig = EcdsaSignature {
            r: base_sig.r,
            s: base_sig.s,
            v,
        };

        let result = service.verify_ecdsa(&message_hash, &sig);
        if result.valid {
            all_rejected = false;
            accepted_positions.push(format!("v={:?}", v));
        }
    }

    if !all_rejected {
        panic!(
            "VULNERABILITY: {:?} positions accepted invalid signatures: {:?}",
            accepted_positions.len(),
            accepted_positions
        );
    }

    println!("✅ All {:?} bit-flip variants rejected", 32 * 8 * 2 + 9);
}

/// BRUTAL TEST: Zero signature components
#[test]
fn brutal_zero_signature_components() {
    let service = SignatureVerificationService::new(MockMempoolGateway);
    let message_hash = [0xAB; 32];

    let test_cases = vec![
        ("r=0, s=0", [0u8; 32], [0u8; 32]),
        ("r=0, s=valid", [0u8; 32], [0x12; 32]),
        ("r=valid, s=0", [0x12; 32], [0u8; 32]),
        ("r=max, s=max", [0xFF; 32], [0xFF; 32]),
        (
            "r=1, s=1",
            {
                let mut a = [0u8; 32];
                a[31] = 1;
                a
            },
            {
                let mut a = [0u8; 32];
                a[31] = 1;
                a
            },
        ),
    ];

    for (name, r, s) in test_cases {
        let sig = EcdsaSignature { r, s, v: 27 };
        let result = service.verify_ecdsa(&message_hash, &sig);

        assert!(
            !result.valid,
            "VULNERABILITY: '{:?}' signature was ACCEPTED!",
            name
        );
    }

    println!("✅ All edge-case signature components rejected");
}

/// BRUTAL TEST: Message hash manipulation
///
/// Same signature should NOT work for different messages
#[test]
fn brutal_message_hash_binding() {
    let service = SignatureVerificationService::new(MockMempoolGateway);

    let original_hash = [0xAB; 32];
    let sig = EcdsaSignature {
        r: [0x12; 32],
        s: [0x34; 32],
        v: 27,
    };

    // Test with slightly modified hashes
    for byte_idx in 0..32 {
        let mut modified_hash = original_hash;
        modified_hash[byte_idx] ^= 0x01;

        let result = service.verify_ecdsa(&modified_hash, &sig);

        // Both should be rejected (invalid sig), but importantly
        // the results should be consistent
        assert!(
            !result.valid,
            "VULNERABILITY: Modified hash at position {:?} accepted same signature!",
            byte_idx
        );
    }

    println!("✅ Signature bound to message hash");
}

// ============================================================================
// IDENTITY SPOOFING TESTS
// ============================================================================

/// BRUTAL TEST: NodeId collision attempt
///
/// Two peers claim the same NodeId from different IPs
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn brutal_nodeid_collision_attack() {
    let local_id = NodeId::new([0u8; 32]);
    let config = KademliaConfig::default();
    let table = Arc::new(Mutex::new(RoutingTable::new(local_id, config)));
    let now = Timestamp::new(1000);

    // Victim's real NodeId
    let victim_id = NodeId::new([0x88; 32]);

    // Real peer
    let real_peer = PeerInfo::new(
        victim_id.clone(),
        SocketAddr::new(IpAddr::v4(8, 8, 8, 8), 30303), // Real IP
        now,
    );

    // Attacker claiming same NodeId
    let fake_peer = PeerInfo::new(
        victim_id.clone(),
        SocketAddr::new(IpAddr::v4(192, 168, 1, 100), 30303), // Attacker IP
        now,
    );

    // Add real peer first
    {
        let mut guard = table.lock().await;
        let _ = guard.stage_peer(real_peer, now);
        let _ = guard.on_verification_result(&victim_id, true, now);
    }

    // Attacker tries to overwrite
    {
        let mut guard = table.lock().await;
        let result = guard.stage_peer(fake_peer, now);

        // Get current peer for this NodeId
        let closest = guard.find_closest_peers(&victim_id, 1);

        if !closest.is_empty() {
            let current = &closest[0];
            if current.socket_addr.ip != IpAddr::v4(8, 8, 8, 8) {
                panic!(
                    "VULNERABILITY: Attacker overwrote real peer! \
                     Original IP: 8.8.8.8, Current IP: {:?}",
                    current.socket_addr.ip
                );
            }
        }
    }

    println!("✅ NodeId collision rejected - original peer preserved");
}

/// BRUTAL TEST: Concurrent identity claims
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn brutal_concurrent_identity_race() {
    let local_id = NodeId::new([0u8; 32]);
    let config = KademliaConfig::default();
    let table = Arc::new(Mutex::new(RoutingTable::new(local_id, config)));
    let now = Timestamp::new(1000);

    // 10 attackers all claim the same NodeId concurrently
    let disputed_id = NodeId::new([0xDD; 32]);

    let mut handles = vec![];
    for attacker in 0..10u8 {
        let table_clone = table.clone();
        let id = disputed_id.clone();

        handles.push(tokio::spawn(async move {
            let peer = PeerInfo::new(
                id.clone(),
                SocketAddr::new(IpAddr::v4(10, 0, 0, attacker), 30303),
                Timestamp::new(1000),
            );

            let mut guard = table_clone.lock().await;
            let stage_result = guard.stage_peer(peer, Timestamp::new(1000));
            let verify_result = guard.on_verification_result(&id, true, Timestamp::new(1001));
            drop(guard);

            (attacker, stage_result.is_ok(), verify_result.is_ok())
        }));
    }

    let mut results = vec![];
    for handle in handles {
        results.push(handle.await.unwrap());
    }

    // Count how many "succeeded"
    let staged: Vec<_> = results.iter().filter(|(_, s, _)| *s).collect();
    let verified: Vec<_> = results.iter().filter(|(_, _, v)| *v).collect();

    // Only ONE should ultimately be in the table
    let guard = table.lock().await;
    let closest = guard.find_closest_peers(&disputed_id, 10);
    let matches: Vec<_> = closest
        .iter()
        .filter(|p| p.node_id == disputed_id)
        .collect();

    assert!(
        matches.len() <= 1,
        "VULNERABILITY: {:?} peers with same NodeId in table! Race condition.",
        matches.len()
    );

    println!(
        "✅ Identity race: {:?} staged, {:?} verified, {:?} in table (should be ≤1)",
        staged.len(),
        verified.len(),
        matches.len()
    );
}

// ============================================================================
// TRANSACTION REPLAY TESTS
// ============================================================================

/// BRUTAL TEST: Transaction replay with same hash
#[test]
fn brutal_transaction_replay_same_hash() {
    let mut pool = TransactionPool::new(MempoolConfig::default());

    let tx = SignedTransaction {
        from: [0xAA; 20],
        to: Some([0xBB; 20]),
        value: U256::from(1_000_000_000_000_000_000u128),
        nonce: 0,
        gas_price: U256::from(1_000_000_000u64),
        gas_limit: 21000,
        data: vec![],
        signature: [0x12; 64],
    };

    let mempool_tx = MempoolTransaction::new(tx.clone(), 1000);
    let hash = mempool_tx.hash;

    // First submission should succeed
    assert!(
        pool.add(mempool_tx).is_ok(),
        "First submission should succeed"
    );

    // Replay should fail
    let replay_tx = MempoolTransaction::new(tx.clone(), 2000);
    let result = pool.add(replay_tx);

    assert!(
        result.is_err(),
        "VULNERABILITY: Transaction replay accepted! Same tx added twice."
    );

    // Verify only one in pool
    assert_eq!(pool.len(), 1, "Pool should have exactly 1 transaction");

    println!("✅ Transaction replay rejected");
}

/// BRUTAL TEST: Nonce reuse attack
#[test]
fn brutal_nonce_reuse_different_recipient() {
    let mut pool = TransactionPool::new(MempoolConfig::default());
    let sender = [0xAA; 20];

    // First transaction: send to 0xBB
    let tx1 = SignedTransaction {
        from: sender,
        to: Some([0xBB; 20]),
        value: U256::from(1_000_000_000_000_000_000u128),
        nonce: 0, // Nonce 0
        gas_price: U256::from(1_000_000_000u64),
        gas_limit: 21000,
        data: vec![],
        signature: [0x11; 64],
    };

    // Second transaction: SAME NONCE, different recipient
    let tx2 = SignedTransaction {
        from: sender,
        to: Some([0xCC; 20]), // Different recipient!
        value: U256::from(1_000_000_000_000_000_000u128),
        nonce: 0, // SAME NONCE!
        gas_price: U256::from(1_000_000_000u64),
        gas_limit: 21000,
        data: vec![],
        signature: [0x22; 64], // Different signature
    };

    pool.add(MempoolTransaction::new(tx1, 1000)).unwrap();
    let result = pool.add(MempoolTransaction::new(tx2, 2000));

    // Without RBF enabled, second should be rejected
    // With RBF, it would need higher gas price
    if result.is_ok() {
        // Check if it's RBF behavior
        let status = pool.status(3000);
        assert_eq!(
            status.pending_count, 1,
            "VULNERABILITY: Both nonce-0 transactions in pool!"
        );
        println!("⚠️ Nonce replacement allowed (RBF behavior)");
    } else {
        println!("✅ Duplicate nonce rejected");
    }
}

// ============================================================================
// MAN-IN-THE-MIDDLE TESTS
// ============================================================================

/// BRUTAL TEST: Modified transaction value
///
/// Attacker intercepts and modifies the 'value' field
#[test]
fn brutal_mitm_value_modification() {
    let service = SignatureVerificationService::new(MockMempoolGateway);

    // Original transaction hash (what was signed)
    let original_hash = [0xAA; 32];

    // Attacker modifies value, creating different hash
    let modified_hash = [0xBB; 32];

    // Original signature (for original_hash)
    let sig = EcdsaSignature {
        r: [0x12; 32],
        s: [0x34; 32],
        v: 27,
    };

    // Verify original fails (invalid sig anyway, but consistent)
    let original_result = service.verify_ecdsa(&original_hash, &sig);

    // Verify modified ALSO fails
    let modified_result = service.verify_ecdsa(&modified_hash, &sig);

    // Both should be invalid (signature doesn't match either)
    assert!(!original_result.valid, "Original should be invalid");
    assert!(!modified_result.valid, "Modified should be invalid");

    // Key: modified should NOT suddenly become valid
    assert_eq!(
        original_result.valid, modified_result.valid,
        "VULNERABILITY: MITM modification changed validity!"
    );

    println!("✅ MITM value modification detected");
}

/// BRUTAL TEST: Peer address spoofing
#[tokio::test]
async fn brutal_peer_address_spoof() {
    let local_id = NodeId::new([0u8; 32]);
    let config = KademliaConfig::default();
    let mut table = RoutingTable::new(local_id, config);
    let now = Timestamp::new(1000);

    // Real peer at IP 8.8.8.8
    let real_id = NodeId::new([0x88; 32]);
    let real_peer = PeerInfo::new(
        real_id.clone(),
        SocketAddr::new(IpAddr::v4(8, 8, 8, 8), 30303),
        now,
    );

    table.stage_peer(real_peer, now).unwrap();
    table.on_verification_result(&real_id, true, now).unwrap();

    // Attacker claims to be at DIFFERENT IP with SAME NodeId
    // This simulates address spoofing
    let spoof_peer = PeerInfo::new(
        real_id.clone(),
        SocketAddr::new(IpAddr::v4(192, 168, 1, 1), 30303), // Spoofed IP
        Timestamp::new(2000),
    );

    let spoof_result = table.stage_peer(spoof_peer, Timestamp::new(2000));

    // Check what IP is recorded
    let closest = table.find_closest_peers(&real_id, 1);
    if !closest.is_empty() {
        let recorded_ip = closest[0].socket_addr.ip;
        if recorded_ip == IpAddr::v4(192, 168, 1, 1) {
            panic!(
                "VULNERABILITY: Address spoof succeeded! \
                 Real IP was 8.8.8.8, now recorded as {:?}",
                recorded_ip
            );
        }
    }

    println!("✅ Address spoofing rejected");
}

// ============================================================================
// CRYPTOGRAPHIC EDGE CASES
// ============================================================================

/// BRUTAL TEST: Signature malleability variations
#[test]
fn brutal_signature_malleability_comprehensive() {
    let service = SignatureVerificationService::new(MockMempoolGateway);
    let message_hash = [0xAB; 32];

    // secp256k1 curve order
    let curve_order: [u8; 32] = [
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36,
        0x41, 0x41,
    ];

    // Half order (EIP-2 boundary)
    let half_order: [u8; 32] = [
        0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D, 0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B,
        0x20, 0xA0,
    ];

    let test_cases = vec![
        ("s = half_order", half_order),
        ("s = half_order + 1", {
            let mut s = half_order;
            let mut carry = 1u16;
            for i in (0..32).rev() {
                let sum = s[i] as u16 + carry;
                s[i] = sum as u8;
                carry = sum >> 8;
            }
            s
        }),
        ("s = curve_order - 1", {
            let mut s = curve_order;
            let mut borrow = 1u16;
            for i in (0..32).rev() {
                let diff = s[i] as i16 - borrow as i16;
                if diff < 0 {
                    s[i] = (diff + 256) as u8;
                    borrow = 1;
                } else {
                    s[i] = diff as u8;
                    borrow = 0;
                }
            }
            s
        }),
        ("s = curve_order", curve_order),
        ("s = curve_order + 1", {
            let mut s = curve_order;
            let mut carry = 1u16;
            for i in (0..32).rev() {
                let sum = s[i] as u16 + carry;
                s[i] = sum as u8;
                carry = sum >> 8;
            }
            s
        }),
    ];

    for (name, s) in test_cases {
        let sig = EcdsaSignature {
            r: [0x12; 32],
            s,
            v: 27,
        };

        let result = service.verify_ecdsa(&message_hash, &sig);

        // All of these should be rejected (invalid or malleability)
        assert!(
            !result.valid,
            "VULNERABILITY: '{:?}' signature was ACCEPTED! s={:?}",
            name,
            &s[..4]
        );
    }

    println!("✅ All malleability variants rejected");
}
