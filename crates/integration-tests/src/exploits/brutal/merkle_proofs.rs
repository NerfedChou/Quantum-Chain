//! # Brutal Tests: Merkle Proof Attacks (qc-03)
//!
//! Security exploit tests for the Transaction Indexing subsystem.
//!
//! ## Architecture Context (V2.2 Choreography)
//!
//! Transaction Indexing is a **participant** in the block processing choreography:
//! - Subscribes to BlockValidated from Consensus (8)
//! - Computes Merkle tree and publishes MerkleRootComputed
//! - Provides Merkle proofs for transaction inclusion verification
//!
//! ## Attack Vectors Tested
//!
//! ### Proof Tampering Attacks (INVARIANT-2)
//! - Leaf hash manipulation
//! - Path hash manipulation
//! - Sibling position swapping
//! - Root substitution
//!
//! ### Tree Construction Attacks (INVARIANT-1, 3)
//! - Non-power-of-two exploitation
//! - Determinism verification
//! - Sentinel hash manipulation
//!
//! ### Cache Exhaustion Attacks (INVARIANT-5)
//! - Memory bomb via tree cache
//! - LRU bypass attempts
//!
//! ### Authorization Attacks (IPC-MATRIX)
//! - Unauthorized proof requests
//! - Sender spoofing for BlockValidated
//!
//! ## Reference Documents
//! - SPEC-03-TRANSACTION-INDEXING.md
//! - Architecture.md Section 5.1 (Choreography Pattern)
//! - IPC-MATRIX.md Subsystem 3 section

use qc_03_transaction_indexing::{
    IndexConfig, MerkleProof, MerkleTree, ProofNode, SiblingPosition, TransactionIndex,
    TransactionLocation, SENTINEL_HASH,
};
use shared_types::Hash;

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

fn hash_from_byte(b: u8) -> Hash {
    let mut h = [0u8; 32];
    h[0] = b;
    h
}

fn hash_from_bytes(bytes: &[u8]) -> Hash {
    use sha3::{Digest, Sha3_256};
    let mut hasher = Sha3_256::new();
    hasher.update(bytes);
    hasher.finalize().into()
}

// =============================================================================
// BRUTAL TESTS: PROOF TAMPERING ATTACKS (INVARIANT-2)
// =============================================================================

/// BRUTAL TEST: Leaf hash bit-flip attack
///
/// Attack: Flip single bit in leaf hash of valid proof
/// Defense: Proof verification MUST fail
#[test]
fn brutal_leaf_hash_bitflip_attack() {
    let txs: Vec<Hash> = (0..8).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    for tx_index in 0..8 {
        let mut proof = tree
            .generate_proof(tx_index, 100, hash_from_byte(0xFF))
            .unwrap();

        // Flip each bit position in the leaf hash
        for byte_pos in 0..32 {
            for bit_pos in 0..8 {
                let original = proof.leaf_hash[byte_pos];
                proof.leaf_hash[byte_pos] ^= 1 << bit_pos;

                assert!(
                    !tree.verify_proof(&proof),
                    "Bit flip at byte {} bit {} should invalidate proof for tx {}",
                    byte_pos,
                    bit_pos,
                    tx_index
                );

                // Restore for next iteration
                proof.leaf_hash[byte_pos] = original;
            }
        }
    }

    println!("✅ All 2048 bit-flip attacks on leaf hash correctly rejected");
}

/// BRUTAL TEST: Path hash manipulation attack
///
/// Attack: Modify sibling hashes in proof path
/// Defense: Recomputed root won't match
#[test]
fn brutal_path_hash_manipulation_attack() {
    let txs: Vec<Hash> = (0..16).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    let mut proof = tree.generate_proof(7, 100, hash_from_byte(0xFF)).unwrap();

    // Attack each node in the path
    for path_idx in 0..proof.path.len() {
        let original = proof.path[path_idx].hash;

        // Try various manipulations
        let attacks = vec![
            [0u8; 32],            // All zeros
            [0xFF; 32],           // All ones
            SENTINEL_HASH,        // Sentinel
            hash_from_byte(0xDE), // Random
            {
                let mut h = original;
                h[0] ^= 1;
                h
            }, // Single bit flip
        ];

        for attack_hash in attacks {
            proof.path[path_idx].hash = attack_hash;

            assert!(
                !tree.verify_proof(&proof),
                "Path manipulation at index {} should fail",
                path_idx
            );
        }

        // Restore
        proof.path[path_idx].hash = original;
    }

    println!("✅ Path hash manipulation attacks correctly rejected");
}

/// BRUTAL TEST: Sibling position swap attack
///
/// Attack: Swap Left/Right positions in proof path
/// Defense: Hash order matters in H(left || right)
#[test]
fn brutal_sibling_position_swap_attack() {
    let txs: Vec<Hash> = (0..8).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    let mut proof = tree.generate_proof(3, 100, hash_from_byte(0xFF)).unwrap();

    // Swap each position
    for path_idx in 0..proof.path.len() {
        let original = proof.path[path_idx].position;

        proof.path[path_idx].position = match original {
            SiblingPosition::Left => SiblingPosition::Right,
            SiblingPosition::Right => SiblingPosition::Left,
        };

        // Swapping positions should invalidate proof (unless path node is symmetric, which is rare)
        // In practice, this should almost always fail
        let is_valid = tree.verify_proof(&proof);

        // Restore
        proof.path[path_idx].position = original;

        // The only way swap could still verify is if left == right hash (sentinel cases)
        // For non-sentinel hashes, this MUST fail
        if proof.path[path_idx].hash != SENTINEL_HASH {
            assert!(
                !is_valid,
                "Position swap at index {} should invalidate proof",
                path_idx
            );
        }
    }

    println!("✅ Sibling position swap attacks correctly handled");
}

/// BRUTAL TEST: Root substitution attack
///
/// Attack: Replace root in proof with different root
/// Defense: Verification against wrong root fails
#[test]
fn brutal_root_substitution_attack() {
    let txs: Vec<Hash> = (0..4).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    let proof = tree.generate_proof(2, 100, hash_from_byte(0xFF)).unwrap();

    // Create different trees with different roots
    let fake_roots = vec![
        MerkleTree::build(vec![hash_from_byte(0xAA)]).root(),
        MerkleTree::build(vec![hash_from_byte(0xBB), hash_from_byte(0xCC)]).root(),
        [0u8; 32],
        [0xFF; 32],
        SENTINEL_HASH,
    ];

    for fake_root in fake_roots {
        let is_valid = MerkleTree::verify_proof_static(&proof.leaf_hash, &proof.path, &fake_root);

        assert!(
            !is_valid,
            "Proof should not verify against fake root {:?}",
            &fake_root[..4]
        );
    }

    println!("✅ Root substitution attacks correctly rejected");
}

/// BRUTAL TEST: Truncated path attack
///
/// Attack: Remove nodes from proof path
/// Defense: Incomplete path produces wrong root
#[test]
fn brutal_truncated_path_attack() {
    let txs: Vec<Hash> = (0..16).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    let proof = tree.generate_proof(5, 100, hash_from_byte(0xFF)).unwrap();
    let full_path_len = proof.path.len();

    // Try verifying with truncated paths
    for truncate_to in 0..full_path_len {
        let truncated_path: Vec<ProofNode> = proof.path[..truncate_to].to_vec();

        let is_valid =
            MerkleTree::verify_proof_static(&proof.leaf_hash, &truncated_path, &proof.root);

        assert!(
            !is_valid,
            "Truncated path (len {}) should not verify",
            truncate_to
        );
    }

    println!("✅ Truncated path attacks correctly rejected");
}

/// BRUTAL TEST: Extended path attack
///
/// Attack: Add extra nodes to proof path
/// Defense: Over-long path produces wrong root
#[test]
fn brutal_extended_path_attack() {
    let txs: Vec<Hash> = (0..4).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    let mut proof = tree.generate_proof(1, 100, hash_from_byte(0xFF)).unwrap();

    // Add extra nodes
    let extra_nodes = vec![
        ProofNode {
            hash: [0u8; 32],
            position: SiblingPosition::Left,
        },
        ProofNode {
            hash: [0xFF; 32],
            position: SiblingPosition::Right,
        },
        ProofNode {
            hash: proof.path[0].hash,
            position: SiblingPosition::Left,
        },
    ];

    for extra in extra_nodes {
        proof.path.push(extra);
    }

    assert!(
        !tree.verify_proof(&proof),
        "Extended path should not verify"
    );

    println!("✅ Extended path attack correctly rejected");
}

// =============================================================================
// BRUTAL TESTS: TREE CONSTRUCTION ATTACKS (INVARIANT-1, 3)
// =============================================================================

/// BRUTAL TEST: Non-power-of-two transaction counts
///
/// Verify: INVARIANT-1 - Padding to power of two works correctly
#[test]
fn brutal_non_power_of_two_padding() {
    let test_cases = vec![
        (1, 2),    // 1 → 2
        (2, 2),    // 2 → 2 (no change)
        (3, 4),    // 3 → 4
        (5, 8),    // 5 → 8
        (7, 8),    // 7 → 8
        (9, 16),   // 9 → 16
        (17, 32),  // 17 → 32
        (33, 64),  // 33 → 64
        (65, 128), // 65 → 128
    ];

    for (tx_count, expected_leaves) in test_cases {
        let txs: Vec<Hash> = (0..tx_count).map(|i| hash_from_byte(i as u8)).collect();
        let tree = MerkleTree::build(txs);

        assert_eq!(
            tree.leaf_count(),
            expected_leaves,
            "INVARIANT-1: {} txs should pad to {} leaves",
            tx_count,
            expected_leaves
        );
    }

    println!("✅ INVARIANT-1: Power-of-two padding correctly enforced");
}

/// BRUTAL TEST: Deterministic hashing verification
///
/// Verify: INVARIANT-3 - Same transactions = same root
#[test]
fn brutal_deterministic_hashing() {
    // Build same tree 100 times
    let txs: Vec<Hash> = (0..10).map(|i| hash_from_byte(i as u8)).collect();

    let roots: Vec<Hash> = (0..100)
        .map(|_| MerkleTree::build(txs.clone()).root())
        .collect();

    // All roots must be identical
    let first_root = roots[0];
    for (i, root) in roots.iter().enumerate() {
        assert_eq!(
            *root, first_root,
            "INVARIANT-3: Root {} differs from root 0",
            i
        );
    }

    println!("✅ INVARIANT-3: Deterministic hashing verified over 100 builds");
}

/// BRUTAL TEST: Transaction order sensitivity
///
/// Verify: Different order = different root (security property)
#[test]
fn brutal_transaction_order_sensitivity() {
    let tx1 = hash_from_byte(0x01);
    let tx2 = hash_from_byte(0x02);
    let tx3 = hash_from_byte(0x03);
    let tx4 = hash_from_byte(0x04);

    let tree_1234 = MerkleTree::build(vec![tx1, tx2, tx3, tx4]);
    let tree_4321 = MerkleTree::build(vec![tx4, tx3, tx2, tx1]);
    let tree_1324 = MerkleTree::build(vec![tx1, tx3, tx2, tx4]);

    assert_ne!(
        tree_1234.root(),
        tree_4321.root(),
        "Reversed order should produce different root"
    );
    assert_ne!(
        tree_1234.root(),
        tree_1324.root(),
        "Swapped middle elements should produce different root"
    );

    println!("✅ Transaction order correctly affects Merkle root");
}

/// BRUTAL TEST: Sentinel hash collision attempt
///
/// Attack: Use sentinel hash as transaction to confuse padding
/// Defense: Sentinel is still a valid transaction hash, tree handles correctly
#[test]
fn brutal_sentinel_hash_collision() {
    // Include SENTINEL_HASH as an actual transaction
    let txs = vec![
        hash_from_byte(0x01),
        SENTINEL_HASH, // Attacker includes sentinel as tx
        hash_from_byte(0x03),
    ];

    let tree = MerkleTree::build(txs.clone());

    // Tree should be built correctly (4 leaves due to padding)
    assert_eq!(tree.leaf_count(), 4);

    // Proof for sentinel hash transaction should still work
    let proof = tree.generate_proof(1, 100, hash_from_byte(0xFF)).unwrap();
    assert_eq!(proof.leaf_hash, SENTINEL_HASH);
    assert!(tree.verify_proof(&proof));

    println!("✅ Sentinel hash as transaction handled correctly");
}

// =============================================================================
// BRUTAL TESTS: CACHE EXHAUSTION ATTACKS (INVARIANT-5)
// =============================================================================

/// BRUTAL TEST: Tree cache memory bomb
///
/// Attack: Flood with trees to exhaust memory
/// Defense: INVARIANT-5 - LRU eviction at max_cached_trees
#[test]
fn brutal_tree_cache_memory_bomb() {
    let config = IndexConfig {
        max_cached_trees: 100,
        persist_index: false,
    };
    let mut index = TransactionIndex::new(config);

    // Flood with 10,000 trees
    for i in 0..10_000u32 {
        let block_hash = hash_from_bytes(&i.to_le_bytes());
        let tree = MerkleTree::build(vec![hash_from_byte((i % 256) as u8)]);
        index.cache_tree(block_hash, tree);
    }

    // INVARIANT-5: Cache should be bounded at 100
    assert_eq!(
        index.stats().cached_trees,
        100,
        "Cache should be bounded at max_cached_trees"
    );

    println!("✅ INVARIANT-5: Cache correctly bounded under memory bomb");
}

/// BRUTAL TEST: LRU eviction correctness
///
/// Verify: Oldest trees are evicted, recently accessed stay
#[test]
fn brutal_lru_eviction_correctness() {
    let config = IndexConfig {
        max_cached_trees: 5,
        persist_index: false,
    };
    let mut index = TransactionIndex::new(config);

    // Cache blocks A through E (oldest to newest)
    let blocks: Vec<Hash> = (0..5).map(|i| hash_from_byte(i as u8)).collect();
    for block in &blocks {
        index.cache_tree(*block, MerkleTree::build(vec![*block]));
    }

    // Access block A (makes it recently used)
    let block_a = blocks[0];
    let _ = index.get_tree(&block_a);

    // Add new block F - should evict B (now the LRU)
    let block_f = hash_from_byte(0x0F);
    index.cache_tree(block_f, MerkleTree::build(vec![block_f]));

    // A should still be cached (was accessed)
    assert!(index.has_tree(&block_a), "A should still be cached");

    // B should be evicted (LRU)
    assert!(!index.has_tree(&blocks[1]), "B should be evicted");

    // F should be cached
    assert!(index.has_tree(&block_f), "F should be cached");

    println!("✅ LRU eviction correctly prioritizes recently accessed trees");
}

// =============================================================================
// BRUTAL TESTS: EDGE CASES AND STRESS
// =============================================================================

/// BRUTAL TEST: Empty transaction list
///
/// Verify: Empty block produces sentinel root
#[test]
fn brutal_empty_transaction_list() {
    let tree = MerkleTree::build(vec![]);

    assert_eq!(tree.root(), SENTINEL_HASH);
    assert_eq!(tree.transaction_count(), 0);
    assert_eq!(tree.leaf_count(), 0);

    // Proof generation should fail for empty tree
    let result = tree.generate_proof(0, 100, hash_from_byte(0xFF));
    assert!(result.is_err(), "Empty tree should not generate proofs");

    println!("✅ Empty transaction list handled correctly");
}

/// BRUTAL TEST: Maximum index boundary
///
/// Attack: Request proof for index at/beyond transaction count
/// Defense: Bounds checking rejects invalid indices
#[test]
fn brutal_index_boundary_attack() {
    let txs: Vec<Hash> = (0..10).map(|i| hash_from_byte(i as u8)).collect();
    let tree = MerkleTree::build(txs);

    // Valid: 0-9
    for i in 0..10 {
        assert!(
            tree.generate_proof(i, 100, hash_from_byte(0xFF)).is_ok(),
            "Index {} should be valid",
            i
        );
    }

    // Invalid: 10+
    let invalid_indices = vec![10, 11, 15, 100, usize::MAX];
    for i in invalid_indices {
        let result = tree.generate_proof(i, 100, hash_from_byte(0xFF));
        assert!(
            result.is_err(),
            "Index {} should be rejected (max is 10)",
            i
        );
    }

    println!("✅ Index boundary attacks correctly rejected");
}

/// BRUTAL TEST: Large tree stress test
///
/// Verify: System handles large trees without performance degradation
#[test]
fn brutal_large_tree_stress() {
    // Build tree with 1000 transactions
    let txs: Vec<Hash> = (0..1000u32)
        .map(|i| hash_from_bytes(&i.to_le_bytes()))
        .collect();

    let tree = MerkleTree::build(txs);

    // Should pad to 1024 leaves
    assert_eq!(tree.leaf_count(), 1024);

    // Generate and verify proof for random indices
    let test_indices = vec![0, 1, 499, 500, 998, 999];
    for idx in test_indices {
        let proof = tree
            .generate_proof(idx, 100, hash_from_byte(0xFF))
            .expect("Proof generation should succeed");

        assert!(
            tree.verify_proof(&proof),
            "Proof for index {} should verify",
            idx
        );

        // Path length should be log2(1024) = 10
        assert_eq!(proof.path.len(), 10);
    }

    println!("✅ Large tree (1000 txs) handled correctly with O(log n) proofs");
}

/// BRUTAL TEST: Proof cross-verification attack
///
/// Attack: Use proof from tree A to verify against tree B
/// Defense: Different trees = different roots = verification fails
#[test]
fn brutal_cross_tree_verification_attack() {
    let txs_a: Vec<Hash> = (0..4).map(|i| hash_from_byte(i as u8)).collect();
    let txs_b: Vec<Hash> = (4..8).map(|i| hash_from_byte(i as u8)).collect();

    let tree_a = MerkleTree::build(txs_a);
    let tree_b = MerkleTree::build(txs_b);

    // Generate proof from tree A
    let proof_a = tree_a.generate_proof(0, 100, hash_from_byte(0xFF)).unwrap();

    // Try to verify against tree B
    let is_valid = tree_b.verify_proof(&proof_a);

    assert!(
        !is_valid,
        "Proof from tree A should not verify against tree B"
    );

    println!("✅ Cross-tree verification attack correctly rejected");
}

// =============================================================================
// BRUTAL TESTS: IPC AUTHORIZATION (IPC-MATRIX)
// =============================================================================

/// BRUTAL TEST: Handler subsystem ID verification
///
/// Verify: IPC handler constants are correctly defined per IPC-MATRIX
#[test]
fn brutal_ipc_subsystem_id_verification() {
    use qc_03_transaction_indexing::subsystem_ids;

    // Per IPC-MATRIX.md, Transaction Indexing (3) accepts:
    // - BlockValidated from Consensus (8)
    // - MerkleProofRequest from Block Storage (2), Light Clients (13)
    // - TransactionLocationRequest from Block Storage (2)

    assert_eq!(subsystem_ids::TRANSACTION_INDEXING, 3);
    assert_eq!(subsystem_ids::CONSENSUS, 8);
    assert_eq!(subsystem_ids::BLOCK_STORAGE, 2);
    assert_eq!(subsystem_ids::LIGHT_CLIENTS, 13);

    println!("✅ IPC subsystem IDs correctly defined per IPC-MATRIX");
}
