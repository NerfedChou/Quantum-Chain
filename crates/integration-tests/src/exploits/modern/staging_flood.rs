//! # Eclipse by Staging (Modern 2024 Attack)
//!
//! Target: SPEC-01 Peer Discovery - Staging Area

use qc_01_peer_discovery::NodeId;
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use tokio::sync::Mutex;

/// Simulates a staging area for pending peer verification
struct StagingArea {
    pending: Vec<(NodeId, u64)>,
    max_size: usize,
    timeout_ms: u64,
}

impl StagingArea {
    fn new(max_size: usize, timeout_ms: u64) -> Self {
        Self {
            pending: Vec::with_capacity(max_size),
            max_size,
            timeout_ms,
        }
    }

    fn add(&mut self, peer_id: NodeId, now: u64) -> bool {
        if self.pending.len() >= self.max_size {
            return false;
        }
        self.pending.push((peer_id, now));
        true
    }

    fn add_priority(&mut self, peer_id: NodeId, now: u64) -> bool {
        if self.pending.len() >= self.max_size {
            if let Some(pos) = self
                .pending
                .iter()
                .position(|(_, ts)| now - ts > self.timeout_ms / 2)
            {
                self.pending.remove(pos);
            } else {
                return false;
            }
        }
        self.pending.push((peer_id, now));
        true
    }

    fn cleanup(&mut self, now: u64) -> usize {
        let before = self.pending.len();
        self.pending
            .retain(|(_, ts)| now.saturating_sub(*ts) < self.timeout_ms);
        before - self.pending.len()
    }

    fn len(&self) -> usize {
        self.pending.len()
    }

    fn is_full(&self) -> bool {
        self.pending.len() >= self.max_size
    }
}

/// Test: Concurrent zombie flood fills staging area
#[tokio::test(flavor = "multi_thread", worker_threads = 10)]
async fn test_staging_zombie_flood() {
    const MAX_STAGING: usize = 1024;
    const TIMEOUT_MS: u64 = 30000;

    let staging = Arc::new(Mutex::new(StagingArea::new(MAX_STAGING, TIMEOUT_MS)));
    let blocked_count = Arc::new(AtomicU32::new(0));
    let mut handles = vec![];

    let start_time = 0u64;

    for attacker in 0..50u8 {
        let staging_clone = staging.clone();
        let blocked = blocked_count.clone();

        handles.push(tokio::spawn(async move {
            for i in 0..100u8 {
                let mut id_bytes = [0u8; 32];
                id_bytes[0] = attacker;
                id_bytes[1] = i;
                let zombie_id = NodeId::new(id_bytes);

                let mut guard = staging_clone.lock().await;
                if !guard.add(zombie_id, start_time) {
                    blocked.fetch_add(1, Ordering::Relaxed);
                }
                drop(guard);
                tokio::task::yield_now().await;
            }
        }));
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let blocked = blocked_count.load(Ordering::Relaxed);

    {
        let guard = staging.lock().await;
        println!(
            "Zombie flood: staging has {}/{}, {} blocked",
            guard.len(),
            MAX_STAGING,
            blocked
        );
        assert!(guard.is_full(), "Staging should be full after flood");
    }

    let legit_peer = NodeId::new([0xFF; 32]);

    {
        let mut guard = staging.lock().await;
        let added = guard.add(legit_peer.clone(), start_time + 1000);

        if added {
            println!("✅ Legitimate peer added (unexpected with tail drop)");
        } else {
            println!("❌ VULNERABLE: Legitimate peer blocked by zombie flood!");
        }
    }

    let priority_peer = NodeId::new([0xFE; 32]);

    {
        let mut guard = staging.lock().await;
        let added = guard.add_priority(priority_peer.clone(), start_time + 20000);

        if added {
            println!("✅ Priority peer evicted zombie and connected");
        } else {
            println!("❌ Priority admission failed");
        }
    }
}

/// Test: Cleanup race - GC vs flood rate
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn test_cleanup_race() {
    const MAX_STAGING: usize = 100;
    const TIMEOUT_MS: u64 = 1000;

    let staging = Arc::new(Mutex::new(StagingArea::new(MAX_STAGING, TIMEOUT_MS)));
    let zombies_added = Arc::new(AtomicU32::new(0));
    let zombies_cleaned = Arc::new(AtomicU32::new(0));

    let mut flood_handles = vec![];

    for attacker in 0..4u8 {
        let staging_clone = staging.clone();
        let added = zombies_added.clone();

        flood_handles.push(tokio::spawn(async move {
            for i in 0..500u16 {
                let mut id_bytes = [0u8; 32];
                id_bytes[0] = attacker;
                id_bytes[1] = (i & 0xFF) as u8;
                id_bytes[2] = (i >> 8) as u8;
                let zombie_id = NodeId::new(id_bytes);
                let time = i as u64 * 10;

                let mut guard = staging_clone.lock().await;
                if guard.add(zombie_id, time) {
                    added.fetch_add(1, Ordering::Relaxed);
                }
                drop(guard);
                tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;
            }
        }));
    }

    // GC handle separate
    let gc_staging = staging.clone();
    let gc_cleaned = zombies_cleaned.clone();
    let gc_handle = tokio::spawn(async move {
        for tick in 0..100u64 {
            let now = tick * 50;

            let mut guard = gc_staging.lock().await;
            let removed = guard.cleanup(now);
            gc_cleaned.fetch_add(removed as u32, Ordering::Relaxed);
            drop(guard);

            tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;
        }
    });

    for handle in flood_handles {
        handle.await.unwrap();
    }
    gc_handle.await.unwrap();

    let added = zombies_added.load(Ordering::Relaxed);
    let cleaned = zombies_cleaned.load(Ordering::Relaxed);

    let guard = staging.lock().await;
    let remaining = guard.len();

    println!(
        "Cleanup race: {} added, {} cleaned, {} remaining",
        added, cleaned, remaining
    );

    if remaining > MAX_STAGING / 2 {
        println!("⚠️ GC falling behind - staging congested");
    } else {
        println!("✅ GC keeping up with flood");
    }
}
