//! # Mempool DEA - Data Availability Exhaustion (Modern 2024)

use qc_06_mempool::domain::entities::{MempoolConfig, MempoolTransaction, SignedTransaction, U256};
use qc_06_mempool::domain::pool::TransactionPool;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use tokio::sync::Mutex;

fn create_large_tx(sender_byte: u8, nonce: u64, data_size: usize) -> MempoolTransaction {
    let signed_tx = SignedTransaction {
        from: [sender_byte; 20],
        to: Some([0xBB; 20]),
        value: U256::zero(),
        nonce,
        gas_price: U256::from(1_000_000_000u64),
        gas_limit: 21000 + (data_size as u64 * 16),
        data: vec![0xDE; data_size],
        signature: [0u8; 64],
    };
    MempoolTransaction::new(signed_tx, 1000)
}

/// Test: Memory exhaustion via large payloads
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_memory_exhaustion_attack() {
    let config = MempoolConfig {
        max_transactions: 100,
        max_gas_per_tx: 100_000_000,
        ..MempoolConfig::default()
    };
    let pool = Arc::new(Mutex::new(TransactionPool::new(config)));
    let total_data_bytes = Arc::new(AtomicUsize::new(0));

    const DATA_SIZE: usize = 50 * 1024;

    let mut handles = vec![];

    for attacker in 0..10u8 {
        let pool_clone = pool.clone();
        let data_counter = total_data_bytes.clone();

        handles.push(tokio::spawn(async move {
            let mut added = 0usize;
            let mut data_added = 0usize;

            for nonce in 0..20u64 {
                let tx = create_large_tx(attacker, nonce, DATA_SIZE);
                let mut guard = pool_clone.lock().await;

                if guard.add(tx).is_ok() {
                    added += 1;
                    data_added += DATA_SIZE;
                }
                drop(guard);
            }

            data_counter.fetch_add(data_added, Ordering::Relaxed);
            added
        }));
    }

    let mut total_added = 0;
    for handle in handles {
        total_added += handle.await.unwrap();
    }

    let data_bytes = total_data_bytes.load(Ordering::Relaxed);
    let data_mb = data_bytes as f64 / (1024.0 * 1024.0);

    let guard = pool.lock().await;
    let status = guard.status(10000);

    println!(
        "DEA Attack: {} txs added, {:.2} MB data, pool reports {} bytes",
        total_added, data_mb, status.memory_bytes
    );

    assert!(
        guard.len() <= 100,
        "Pool exceeded max_transactions: {}",
        guard.len()
    );
}

/// Test: Mixed workload (legit + attack)
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_mixed_workload() {
    let config = MempoolConfig {
        max_transactions: 200,
        max_gas_per_tx: 50_000_000,
        ..MempoolConfig::default()
    };
    let pool = Arc::new(Mutex::new(TransactionPool::new(config)));

    let mut handles = vec![];

    // Legitimate users
    for user in 0..50u8 {
        let pool_clone = pool.clone();
        handles.push(tokio::spawn(async move {
            let tx = MempoolTransaction::new(
                SignedTransaction {
                    from: [user; 20],
                    to: Some([0xCC; 20]),
                    value: U256::zero(),
                    nonce: 0,
                    gas_price: U256::from(50_000_000_000u64),
                    gas_limit: 21000,
                    data: vec![],
                    signature: [0u8; 64],
                },
                1000,
            );
            let mut guard = pool_clone.lock().await;
            guard.add(tx).is_ok()
        }));
    }

    // Attackers
    for attacker in 50..100u8 {
        let pool_clone = pool.clone();
        handles.push(tokio::spawn(async move {
            let tx = create_large_tx(attacker, 0, 25 * 1024);
            let mut guard = pool_clone.lock().await;
            guard.add(tx).is_ok()
        }));
    }

    let mut legit_added = 0;
    let mut attack_added = 0;

    for (i, handle) in handles.into_iter().enumerate() {
        if handle.await.unwrap() {
            if i < 50 {
                legit_added += 1;
            } else {
                attack_added += 1;
            }
        }
    }

    println!(
        "Mixed workload: {} legit, {} attack txs added",
        legit_added, attack_added
    );

    let guard = pool.lock().await;
    let batch = guard.get_for_block(50, u64::MAX);

    let legit_in_batch = batch
        .iter()
        .filter(|tx| tx.gas_price >= U256::from(50_000_000_000u64))
        .count();

    println!(
        "Block selection: {} of top 50 are legitimate high-fee",
        legit_in_batch
    );

    assert!(
        legit_in_batch >= 40,
        "Legitimate high-fee txs should dominate block selection"
    );

    println!("âœ… High-fee legitimate txs prioritized over large attack txs");
}
