//! # Zombie Assembler Attack (Architectural Exploit)
//!
//! Target: Block Storage - Stateful Assembler

use std::collections::HashMap;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use tokio::sync::Mutex;

/// Simulates a pending block assembly
#[derive(Clone)]
struct PendingBlockAssembly {
    block_hash: [u8; 32],
    created_at: u64,
    block_validated: bool,
    merkle_root_computed: bool,
    state_root_computed: bool,
    data_size_bytes: usize,
}

impl PendingBlockAssembly {
    fn new(block_hash: [u8; 32], created_at: u64) -> Self {
        Self {
            block_hash,
            created_at,
            block_validated: false,
            merkle_root_computed: false,
            state_root_computed: false,
            data_size_bytes: 0,
        }
    }

    fn is_complete(&self) -> bool {
        self.block_validated && self.merkle_root_computed && self.state_root_computed
    }

    fn is_zombie(&self, now: u64, timeout_ms: u64) -> bool {
        now.saturating_sub(self.created_at) > timeout_ms && !self.is_complete()
    }
}

/// Simulates Block Storage assembler
struct BlockAssembler {
    pending: HashMap<[u8; 32], PendingBlockAssembly>,
    max_pending: usize,
    timeout_ms: u64,
    total_memory_bytes: usize,
}

impl BlockAssembler {
    fn new(max_pending: usize, timeout_ms: u64) -> Self {
        Self {
            pending: HashMap::new(),
            max_pending,
            timeout_ms,
            total_memory_bytes: 0,
        }
    }

    fn on_block_validated(&mut self, block_hash: [u8; 32], now: u64) -> Result<(), &'static str> {
        if self.pending.len() >= self.max_pending {
            return Err("Max pending assemblies reached");
        }

        let assembly = self
            .pending
            .entry(block_hash)
            .or_insert_with(|| PendingBlockAssembly::new(block_hash, now));
        assembly.block_validated = true;

        let header_size = 512;
        assembly.data_size_bytes += header_size;
        self.total_memory_bytes += header_size;

        Ok(())
    }

    fn on_merkle_root(&mut self, block_hash: [u8; 32]) -> Result<(), &'static str> {
        if let Some(assembly) = self.pending.get_mut(&block_hash) {
            assembly.merkle_root_computed = true;
            let proof_size = 1024;
            assembly.data_size_bytes += proof_size;
            self.total_memory_bytes += proof_size;
            Ok(())
        } else {
            Err("No pending assembly for block")
        }
    }

    fn on_state_root(&mut self, block_hash: [u8; 32]) -> Result<(), &'static str> {
        if let Some(assembly) = self.pending.get_mut(&block_hash) {
            assembly.state_root_computed = true;
            let state_size = 4096;
            assembly.data_size_bytes += state_size;
            self.total_memory_bytes += state_size;
            Ok(())
        } else {
            Err("No pending assembly for block")
        }
    }

    fn finalize_complete(&mut self) -> Vec<[u8; 32]> {
        let complete: Vec<_> = self
            .pending
            .iter()
            .filter(|(_, a)| a.is_complete())
            .map(|(h, a)| (*h, a.data_size_bytes))
            .collect();

        for (hash, size) in &complete {
            self.pending.remove(hash);
            self.total_memory_bytes -= size;
        }

        complete.into_iter().map(|(h, _)| h).collect()
    }

    fn cleanup_zombies(&mut self, now: u64) -> Vec<[u8; 32]> {
        let zombies: Vec<_> = self
            .pending
            .iter()
            .filter(|(_, a)| a.is_zombie(now, self.timeout_ms))
            .map(|(h, a)| (*h, a.data_size_bytes))
            .collect();

        for (hash, size) in &zombies {
            self.pending.remove(hash);
            self.total_memory_bytes -= size;
        }

        zombies.into_iter().map(|(h, _)| h).collect()
    }

    fn pending_count(&self) -> usize {
        self.pending.len()
    }

    fn memory_bytes(&self) -> usize {
        self.total_memory_bytes
    }
}

/// Test: Zombie assembly flood attack
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn test_zombie_assembly_flood() {
    const MAX_PENDING: usize = 1000;
    const TIMEOUT_MS: u64 = 5000;

    let assembler = Arc::new(Mutex::new(BlockAssembler::new(MAX_PENDING, TIMEOUT_MS)));
    let rejected_count = Arc::new(AtomicUsize::new(0));
    let gc_total_cleaned = Arc::new(AtomicUsize::new(0));

    let mut flood_handles = vec![];

    for attacker in 0..10u8 {
        let asm = assembler.clone();
        let rejected = rejected_count.clone();

        flood_handles.push(tokio::spawn(async move {
            for i in 0..500u16 {
                let mut block_hash = [0u8; 32];
                block_hash[0] = attacker;
                block_hash[1] = (i >> 8) as u8;
                block_hash[2] = (i & 0xFF) as u8;

                let time = (attacker as u64 * 500 + i as u64) * 10;

                let mut guard = asm.lock().await;
                if guard.on_block_validated(block_hash, time).is_err() {
                    rejected.fetch_add(1, Ordering::Relaxed);
                }
                drop(guard);
                tokio::task::yield_now().await;
            }
        }));
    }

    // GC task
    let gc_asm = assembler.clone();
    let gc_cleaned = gc_total_cleaned.clone();
    let gc_handle = tokio::spawn(async move {
        for tick in 0..100u64 {
            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;

            let now = tick * 100;
            let mut guard = gc_asm.lock().await;
            let cleaned = guard.cleanup_zombies(now);
            gc_cleaned.fetch_add(cleaned.len(), Ordering::Relaxed);
        }
    });

    for handle in flood_handles {
        handle.await.unwrap();
    }
    gc_handle.await.unwrap();

    let rejected = rejected_count.load(Ordering::Relaxed);
    let cleaned = gc_total_cleaned.load(Ordering::Relaxed);
    let guard = assembler.lock().await;

    println!(
        "Zombie flood: {} rejected at limit, {} cleaned by GC, {} remaining",
        rejected,
        cleaned,
        guard.pending_count()
    );

    let memory_mb = guard.memory_bytes() as f64 / (1024.0 * 1024.0);
    println!("Memory usage: {:.2} MB", memory_mb);

    assert!(
        guard.pending_count() <= MAX_PENDING,
        "Pending assemblies exceeded limit: {}",
        guard.pending_count()
    );

    if rejected > 0 {
        println!("✅ Flood attack limited by max_pending");
    } else {
        println!("⚠️ All attacks accepted - may need smaller limit");
    }
}

/// Test: Memory tracking
#[test]
fn test_memory_tracking() {
    let mut assembler = BlockAssembler::new(100, 30000);

    for i in 0..10u8 {
        let mut block_hash = [0u8; 32];
        block_hash[0] = i;

        assembler.on_block_validated(block_hash, 0).unwrap();
        assembler.on_merkle_root(block_hash).unwrap();
        assembler.on_state_root(block_hash).unwrap();
    }

    let expected_memory = 10 * 5632;
    assert_eq!(
        assembler.memory_bytes(),
        expected_memory,
        "Memory tracking mismatch"
    );

    let finalized = assembler.finalize_complete();
    assert_eq!(finalized.len(), 10);

    assert_eq!(
        assembler.memory_bytes(),
        0,
        "Memory not freed after finalize"
    );

    println!("✅ Memory tracking accurate");
}
