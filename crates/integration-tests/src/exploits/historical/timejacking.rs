//! # Timejacking Attack (Bitcoin 2011)
//!
//! ## Attack Vector
//! An attacker spins up 100 nodes that all report a timestamp T + 59 minutes.
//! They try to drag the victim node's internal clock forward until it rejects
//! legitimate blocks from the real network.
//!
//! ## Architecture.md Reference
//! "Timestamps must be within a 60-second window"
//!
//! ## Test Scenarios
//! 1. Attacker nodes report progressively drifted timestamps
//! 2. Legitimate node with bad NTP config
//! 3. Median time protection

use qc_01_peer_discovery::{
    IpAddr, KademliaConfig, NodeId, PeerInfo, RoutingTable, SocketAddr, Timestamp,
};
use std::sync::Arc;
use tokio::sync::Mutex;

/// Maximum allowed timestamp drift in seconds
const MAX_TIMESTAMP_DRIFT_SECS: i64 = 60;

/// Simulates a peer reporting a specific timestamp
struct TimestampedPeer {
    peer: PeerInfo,
    reported_time: i64,
}

impl TimestampedPeer {
    fn new(id_byte: u8, time_offset_secs: i64) -> Self {
        let peer = PeerInfo::new(
            NodeId::new([id_byte; 32]),
            SocketAddr::new(IpAddr::v4(192, 168, 1, id_byte), 30303),
            Timestamp::new(1000),
        );
        let reported_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
            + time_offset_secs;

        Self {
            peer,
            reported_time,
        }
    }
}

/// Calculates median time from peer timestamps
fn calculate_median_time(peer_times: &[i64], local_time: i64) -> i64 {
    if peer_times.is_empty() {
        return local_time;
    }

    let mut times = peer_times.to_vec();
    times.push(local_time);
    times.sort();

    let mid = times.len() / 2;
    if times.len() % 2 == 0 {
        (times[mid - 1] + times[mid]) / 2
    } else {
        times[mid]
    }
}

/// Checks if a timestamp is within acceptable range
fn is_timestamp_valid(timestamp: i64, reference_time: i64) -> bool {
    (timestamp - reference_time).abs() <= MAX_TIMESTAMP_DRIFT_SECS
}

/// Test: Attacker nodes with future timestamps
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_timejacking_future_drift() {
    let local_id = NodeId::new([0xFF; 32]);
    let config = KademliaConfig::default();
    let now = Timestamp::new(1000);
    let routing_table = Arc::new(Mutex::new(RoutingTable::new(local_id, config)));

    let local_time = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;

    // Phase 1: 100 attacker nodes each report time +59 seconds
    let mut attacker_times = vec![];
    let mut handles = vec![];

    for i in 0..100u8 {
        let rt = routing_table.clone();
        handles.push(tokio::spawn(async move {
            let attacker = TimestampedPeer::new(i, 59);
            let mut guard = rt.lock().await;
            let _ = guard.stage_peer(attacker.peer, Timestamp::new(1000));
            attacker.reported_time
        }));
    }

    for handle in handles {
        attacker_times.push(handle.await.unwrap());
    }

    let median_time = calculate_median_time(&attacker_times, local_time);

    println!(
        "Local time: {}, Median time: {}, Drift: {} seconds",
        local_time,
        median_time,
        median_time - local_time
    );

    let drift = median_time - local_time;
    println!("⚠️ Timejacking drift detected: {} seconds", drift);

    let real_block_time = local_time;
    let would_reject = !is_timestamp_valid(real_block_time, median_time);

    if would_reject {
        println!("❌ VULNERABLE: Node would reject legitimate blocks!");
    } else {
        println!("✅ DEFENDED: Node still accepts legitimate blocks");
    }
}

/// Test: Gradual time drift (boiling frog attack)
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_timejacking_gradual_drift() {
    let local_time = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;

    let mut peer_times: Vec<i64> = vec![];
    let mut current_drift = 0i64;

    for minute in 0..60 {
        current_drift += 1;

        for _ in 0..10 {
            peer_times.push(local_time + current_drift);
        }

        for _ in 0..2 {
            peer_times.push(local_time);
        }

        let median =
            calculate_median_time(&peer_times[peer_times.len() - 12..].to_vec(), local_time);
        let drift_from_real = median - local_time;

        if drift_from_real.abs() > MAX_TIMESTAMP_DRIFT_SECS {
            println!(
                "⚠️ Drift exceeded threshold at minute {}: {} seconds",
                minute, drift_from_real
            );
            break;
        }
    }

    println!(
        "Gradual drift attack: final drift = {} seconds after 60 minutes",
        current_drift
    );
}

/// Test: Bad NTP config (legitimate edge case)
#[test]
fn test_bad_ntp_config_handling() {
    let local_time = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;

    let bad_ntp_time = local_time + 30;
    let peer_times: Vec<i64> = (0..10).map(|_| local_time).collect();
    let median = calculate_median_time(&peer_times, bad_ntp_time);
    let drift_from_correct = (median - local_time).abs();

    println!(
        "Bad NTP node: local thinks {}, peers say {}, median = {}",
        bad_ntp_time, local_time, median
    );

    assert!(
        drift_from_correct < 5,
        "Median should be close to correct time, got drift of {} seconds",
        drift_from_correct
    );

    println!("✅ Bad NTP node doesn't poison network time");
}

/// Test: Defense - bounded time adjustment
#[test]
fn test_defense_bounded_adjustment() {
    let local_time = 1000000i64;
    let all_malicious: Vec<i64> = (0..100).map(|_| local_time + 3600).collect();

    const MAX_ADJUSTMENT: i64 = 70;

    let raw_median = calculate_median_time(&all_malicious, local_time);
    let bounded_adjustment = (raw_median - local_time).clamp(-MAX_ADJUSTMENT, MAX_ADJUSTMENT);
    let adjusted_time = local_time + bounded_adjustment;

    println!(
        "Raw median: {}, Bounded adjustment: {}, Adjusted time: {}",
        raw_median, bounded_adjustment, adjusted_time
    );

    assert!(
        (adjusted_time - local_time).abs() <= MAX_ADJUSTMENT,
        "Bounded adjustment exceeded: {} > {}",
        (adjusted_time - local_time).abs(),
        MAX_ADJUSTMENT
    );

    println!("✅ Bounded adjustment prevents timejacking");
}
