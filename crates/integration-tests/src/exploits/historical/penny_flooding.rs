//! # Penny-Flooding / Dust Attack (Bitcoin History)
//!
//! ## Attack Vector
//! Submit thousands of valid transactions with minimum gas price and minimum size.
//! Fill the mempool with spam, preventing legitimate transactions from entering.

use qc_06_mempool::domain::entities::{MempoolConfig, MempoolTransaction, SignedTransaction, U256};
use qc_06_mempool::domain::pool::TransactionPool;
use std::sync::Arc;
use tokio::sync::Mutex;

fn create_tx(sender_byte: u8, nonce: u64, gas_price: u64) -> MempoolTransaction {
    let signed_tx = SignedTransaction {
        from: [sender_byte; 20],
        to: Some([0xBB; 20]),
        value: U256::zero(),
        nonce,
        gas_price: U256::from(gas_price),
        gas_limit: 21000,
        data: vec![],
        signature: [0u8; 64],
    };
    MempoolTransaction::new(signed_tx, 1000)
}

/// Test: Concurrent penny-flooding from 50 attackers
#[tokio::test(flavor = "multi_thread", worker_threads = 10)]
async fn test_concurrent_penny_flooding() {
    let config = MempoolConfig {
        max_transactions: 500,
        min_gas_price: U256::from(1_000_000_000u64),
        ..MempoolConfig::default()
    };
    let pool = Arc::new(Mutex::new(TransactionPool::new(config)));
    let mut handles = vec![];

    for attacker_id in 0..50u8 {
        let pool_clone = pool.clone();
        handles.push(tokio::spawn(async move {
            let mut added = 0u32;
            for nonce in 0..20u64 {
                let tx = create_tx(attacker_id, nonce, 1_000_000_000);
                let mut guard = pool_clone.lock().await;
                if guard.add(tx).is_ok() {
                    added += 1;
                }
                drop(guard);
                tokio::task::yield_now().await;
            }
            added
        }));
    }

    let mut total_spam = 0u32;
    for handle in handles {
        total_spam += handle.await.unwrap();
    }

    println!("Phase 1: {} spam transactions added", total_spam);

    {
        let guard = pool.lock().await;
        println!("Pool size after flooding: {}", guard.len());
        assert!(guard.len() >= 450, "Pool should be mostly full");
    }

    let legit_tx = create_tx(0xFF, 0, 50_000_000_000);
    let legit_hash = legit_tx.hash;

    {
        let mut guard = pool.lock().await;
        let result = guard.add(legit_tx);

        assert!(
            result.is_ok(),
            "CRITICAL: High-fee tx was rejected! Pool broken. Error: {:?}",
            result
        );
        assert!(
            guard.contains(&legit_hash),
            "High-fee tx not in pool after add!"
        );
    }

    {
        let guard = pool.lock().await;
        let batch = guard.get_for_block(10, u64::MAX);

        let high_fee_position = batch
            .iter()
            .position(|tx| tx.hash == legit_hash)
            .expect("High-fee tx not in block selection!");

        println!(
            "✅ Penny-Flooding Defense: High-fee tx at position {} of {}",
            high_fee_position,
            batch.len()
        );

        assert!(
            high_fee_position < 5,
            "High-fee tx should be prioritized, but was at position {}",
            high_fee_position
        );
    }
}

/// Test: Eviction battle
#[tokio::test(flavor = "multi_thread", worker_threads = 10)]
async fn test_eviction_battle() {
    let config = MempoolConfig {
        max_transactions: 100,
        min_gas_price: U256::from(1_000_000_000u64),
        ..MempoolConfig::default()
    };
    let pool = Arc::new(Mutex::new(TransactionPool::new(config)));

    {
        let mut guard = pool.lock().await;
        for i in 0..100u8 {
            let tx = create_tx(i, 0, 1_000_000_000);
            guard.add(tx).unwrap();
        }
    }

    let mut handles = vec![];
    for user_id in 100..110u8 {
        let pool_clone = pool.clone();
        let fee = (user_id as u64 - 99) * 10_000_000_000;

        handles.push(tokio::spawn(async move {
            let tx = create_tx(user_id, 0, fee);
            let hash = tx.hash;
            let mut guard = pool_clone.lock().await;
            let result = guard.add(tx);
            (user_id, fee, result.is_ok(), hash)
        }));
    }

    let mut results = vec![];
    for handle in handles {
        results.push(handle.await.unwrap());
    }

    let successful: Vec<_> = results.iter().filter(|(_, _, ok, _)| *ok).collect();

    println!(
        "Eviction battle: {} of 10 high-fee users succeeded",
        successful.len()
    );

    let guard = pool.lock().await;
    let batch = guard.get_for_block(10, u64::MAX);

    let high_fee_count = batch
        .iter()
        .filter(|tx| tx.gas_price >= U256::from(10_000_000_000u64))
        .count();

    println!("✅ Top 10 transactions: {} are high-fee", high_fee_count);

    assert!(
        high_fee_count >= 5,
        "High-fee transactions should dominate top of block"
    );
}
