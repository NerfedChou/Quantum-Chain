//! # Exploit Test Harness
//!
//! Real-world adversarial attack simulations.
//!
//! ## Key Difference from Unit Tests
//! - Unit tests: "Does 1 + 1 = 2?"
//! - Exploit tests: "Does 1 + 1 = 2 when 500 threads are screaming?"
//!
//! ## Attack Categories
//!
//! ### Phase 1: Historical Attack Reproductions (3 Subsystems)
//! Target: qc-01, qc-06, qc-10 only
//! - `phase1_exploits::mt_gox_malleability` - Signature S-value flip (2014)
//! - `phase1_exploits::wormhole_bypass` - Mock injection attack (2022)
//! - `phase1_exploits::eclipse_table_poisoning` - Routing table flood
//! - `phase1_exploits::dust_exhaustion` - Mempool fee-based eviction
//!
//! ### Historical (Bitcoin/Ethereum Lessons)
//! - `historical::timejacking` - Clock manipulation (Bitcoin 2011)
//! - `historical::penny_flooding` - Dust/spam attacks
//! - `historical::eclipse` - Node isolation
//!
//! ### Modern (2024 Vectors)
//! - `modern::staging_flood` - Eclipse by staging area
//! - `modern::data_exhaustion` - Memory exhaustion via payloads
//!
//! ### Architectural (Design Exploits)
//! - `architectural::ghost_transaction` - Two-Phase Commit gap
//! - `architectural::zombie_assembler` - Orphaned pending blocks
//!
//! ### Brutal (War Games - No Mercy)
//! - `brutal::legit_vs_fake` - Spoofing detection tests
//! - `brutal::under_pressure` - Concurrent multi-thread attacks
//! - `brutal::breach_isolation` - Container/subsystem isolation
//! - `brutal::crash_recovery` - System failure handling

#[cfg(test)]
pub mod architectural;
#[cfg(test)]
pub mod brutal;
#[cfg(test)]
pub mod historical;
#[cfg(test)]
pub mod modern;
#[cfg(test)]
pub mod phase1_exploits;

// Re-export common test utilities
#[cfg(test)]
pub mod helpers {
    use qc_06_mempool::domain::entities::{MempoolTransaction, SignedTransaction, U256};

    /// Create a basic signed transaction
    pub fn create_signed_tx(sender_byte: u8, nonce: u64, gas_price: u64) -> SignedTransaction {
        SignedTransaction {
            from: [sender_byte; 20],
            to: Some([0xBB; 20]),
            value: U256::zero(),
            nonce,
            gas_price: U256::from(gas_price),
            gas_limit: 21000,
            data: vec![],
            signature: [0u8; 64],
        }
    }

    /// Create a signed transaction with data payload
    pub fn create_signed_tx_with_data(
        sender_byte: u8,
        nonce: u64,
        gas_price: u64,
        data_size: usize,
    ) -> SignedTransaction {
        SignedTransaction {
            from: [sender_byte; 20],
            to: Some([0xBB; 20]),
            value: U256::zero(),
            nonce,
            gas_price: U256::from(gas_price),
            gas_limit: 21000 + (data_size as u64 * 16),
            data: vec![0xDE; data_size],
            signature: [0u8; 64],
        }
    }

    /// Create a mempool transaction
    pub fn create_tx(sender_byte: u8, nonce: u64, gas_price: u64) -> MempoolTransaction {
        let signed_tx = create_signed_tx(sender_byte, nonce, gas_price);
        MempoolTransaction::new(signed_tx, 1000)
    }

    /// Create a mempool transaction with timestamp
    pub fn create_tx_at(
        sender_byte: u8,
        nonce: u64,
        gas_price: u64,
        added_at: u64,
    ) -> MempoolTransaction {
        let signed_tx = create_signed_tx(sender_byte, nonce, gas_price);
        MempoolTransaction::new(signed_tx, added_at)
    }

    /// Create a mempool transaction with data
    pub fn create_tx_with_data(
        sender_byte: u8,
        nonce: u64,
        gas_price: u64,
        data_size: usize,
    ) -> MempoolTransaction {
        let signed_tx = create_signed_tx_with_data(sender_byte, nonce, gas_price, data_size);
        MempoolTransaction::new(signed_tx, 1000)
    }

    /// Keccak256 hash function
    pub fn keccak256(data: &[u8]) -> [u8; 32] {
        use sha3::{Digest, Keccak256};
        let mut hasher = Keccak256::new();
        hasher.update(data);
        let result = hasher.finalize();
        let mut hash = [0u8; 32];
        hash.copy_from_slice(&result);
        hash
    }
}
