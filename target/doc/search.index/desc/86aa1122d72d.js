rd_("ChMaximum supported value for the recovery ID (inclusive).AhMultiplicative identity.AiReturns self + rhs mod n.AnModulo multiplies two scalars.BlCreate a new error with no associated sourceDhCreate a new <code>RecoveryId</code> from the following 1-bit arguments:AiReturns self - rhs mod n.Am256-bit unsigned big integer.lZero scalar.AoReturns the argument unchanged.00000000BaCalls <code>U::from(self)</code>.00000000BlRustCrypto: secp256k1 (K-256) elliptic curveC`Tonelli-Shank\xe2\x80\x99s algorithm for q mod 16 = 1 \xe2\x80\xa6AaSignature errors.0CcElliptic Curve Digital Signature Algorithm (ECDSA).CkPreferred digest to use when computing ECDSA signatures \xe2\x80\xa6CbScalars are elements in the finite field modulo n.AcDoubles this point.AkLow-level ECDSA primitives.AcInverts the scalar.AcNegates the scalar.ClGenerate a cryptographically random <code>SigningKey</code>.AjModulo squares the scalar.AmChecks if the scalar is zero.C`Taproot Schnorr signatures as defined in BIP340.ClConvert this <code>RecoveryId</code> into a <code>u8</code>.CfAdditive identity of the group: the point at infinity.0CiReturns the identity of the group: the point at infinity.CmReturns the additive identity of SECP256k1, also known as \xe2\x80\xa6BmIs the affine y-coordinate of \xf0\x9d\x91\x98\xc3\x97\xf0\x9d\x91\xae odd?AjCompute Schnorr signature.BiReturns the SEC1 encoding of this scalar.AcSerialize as bytes.0BbSerialize this signature as bytes.B`Convert to curve representation.BmSize of a Taproot Schnorr signature in bytes.AhBase point of secp256k1.0Amsecp256k1 (K-256) public key.Basecp256k1 (K-256) elliptic curve.Amsecp256k1 (K-256) secret key.BfECDSA/secp256k1 signature (fixed-size)BoTaproot Schnorr signature as defined in BIP340.CfBytes used by a wide reduction: twice the width of \xe2\x80\xa6CjBorrow the inner <code>AffinePoint</code> this type wraps.ClCheck whether <code>self</code> is equal to an affine point.CiConvert a <code>u8</code> into a <code>RecoveryId</code>.CmAttempts to parse the given byte array as an SEC1-encoded \xe2\x80\xa6BdReturns the base point of secp256k1.BdReturns the base point of SECP256k1.C`Returns the affine representation of this point.Cdsecp256k1 (K-256) field element serialized as bytes.BaRecovery IDs, a.k.a. \xe2\x80\x9crecid\xe2\x80\x9d.AkECDSA/secp256k1 signing keyAlTaproot Schnorr signing key.BoUpcast to an <code>RngCore</code> trait object.DkPartial implementation of the <code>bits2int</code> function as defined \xe2\x80\xa6C`Parse signing key from big endian-encoded bytes.CiParse verifying key from big endian-encoded x-coordinate.AjCompute Schnorr signature.Cfsecp256k1 curve point expressed in affine coordinates.BmCreate a new error with an associated source.BaIs this point the identity point?AhRight shifts the scalar.BmECDSA/secp256k1 signature (ASN.1 DER encoded)BkSEC1-encoded secp256k1 (K-256) curve point.CbECDSA/secp256k1 verification key (i.e. public key)AnTaproot Schnorr verifying key.CnCalculates SECP256k1 endomorphism: <code>self * lambda</code>.CjDid the affine x-coordinate of \xf0\x9d\x91\x98\xc3\x97\xf0\x9d\x91\xae overflow the \xe2\x80\xa6ClAn extension trait that is automatically implemented for \xe2\x80\xa6C`Non-zero secp256k1 (K-256) scalar field element.CdTry to sign the given prehashed message using ECDSA.CeVerify message digest against the provided signature.DgGet the <code>VerifyingKey</code> that corresponds to this signing key.BnTaproot Schnorr signature serialized as bytes.CgFast variable-time inversion using Stein\xe2\x80\x99s algorithm.CmSign a prehashed message digest using the provided secret \xe2\x80\xa6CfCompressed SEC1-encoded secp256k1 (K-256) curve point.DgBind a preferred <code>Digest</code> algorithm to an elliptic curve \xe2\x80\xa6CiA point on the secp256k1 curve in projective coordinates.BoVerify the given prehashed message using ECDSA.ClReturns a (nearly) uniformly-random scalar, generated in \xe2\x80\xa6CfReturns a uniformly-random scalar, generated using \xe2\x80\xa6DeCalculates <code>k * G</code>, where <code>G</code> is the generator.CkVerify the prehashed message against the provided ECDSA \xe2\x80\xa60D`Borrow the secret <code>NonZeroScalar</code> value for this key.CoAttempts to parse the given <code>EncodedPoint</code> as an \xe2\x80\xa6BbTry to sign the prehashed message.CiGiven a public key, message, and signature, use trial \xe2\x80\xa6AjCompute Schnorr signature.CjGiven a public key, message digest, and signature, use \xe2\x80\xa6CjTry to sign the given message digest deterministically \xe2\x80\xa61")